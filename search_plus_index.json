{"./":{"url":"./","title":"架构师手册","keywords":"","body":"架构师手册 架构，是一种递进的能力。 本书主要内容来自《一线架构师实践指南》 - 温昱 在线阅读 可以通过GitBook或者Github来在线阅读。 也可以下载PDF、ePub或者Mobi版本。 项目源码 项目源码存放于Github上，见https://github.com/tonydeng/architect-manual。 "},"ch1/":{"url":"ch1/","title":"第1章 手册简介","keywords":"","body":"第1章 手册简介 架构设计能力，因为掌握起来而显得珍贵。 期望用这本手册来概括一线架构师经常面对的实践困惑，并给出ADMEMS方法的应对之策。 扩展阅读 软件架构在不断发展，但它依然是一个尚不成熟的学科。 --Len Bass 《软件架构实践（第2版）》 推动软件工程研究不断发展的，常是实际生产或使用软件时遇到的。 -- Mary Shaw, 《The Golden Age of Software Architecture》 "},"ch1/1.1.html":{"url":"ch1/1.1.html","title":"1.1. 一线架构师:6个经典困惑","keywords":"","body":"1.1. 一线架构师:6个经典困惑 一线架构师经常面对的实践困惑，可以用下面的图来概括。其中，涉及了“4个实际问题的困惑”，以及“两个职业发展的困惑”。 "},"ch1/1.2.html":{"url":"ch1/1.2.html","title":"1.2. 4个核心主张","keywords":"","body":"1.2. 4个核心主张 画龙须点睛。 在介绍具体方法之前，先阐述4个核心主张。 方法体系是大趋势 质疑驱动的架构设计 多阶段方法 内置最佳实践的方法 这4个核心主张可帮助读者领会ADMEMS方法之精神。 "},"ch1/1.2.1.html":{"url":"ch1/1.2.1.html","title":"1.2.1. 方法体系是大趋势","keywords":"","body":"1.2.1. 方法体系是大趋势 单一方法已经无法解决复杂的业务需求，一线架构师真正需要的是覆盖“需请进，架构出”全过程的实践指导。 只有综合了不同方法优点的“方法体系”才能堪此重任。 ADMEMS是“Architectural Design Method has been Extended Method System”的缩写。ADMEMS并不是单一方法，而是由多个各具特点的方法组成的方法体系。 ADMEMS 是“Architectural Design Method has been Extended to Method System(将架构设计方法扩展到方法体系)”的缩写。 "},"ch1/1.2.2.html":{"url":"ch1/1.2.2.html","title":"1.2.2. 质疑驱动的架构设计","keywords":"","body":"1.2.2. 质疑驱动的架构设计 毫无疑问，架构设计是需求驱动的，而不是模型驱动的。 但需求驱动的说法，不太传神——当你很清楚需求却依然设计不出架构时就足以 说明“需求驱动的架构设计”的总结还“缺点儿什么”。 架构设计是一门艺术，你不可能把“一桶需求”倒进某台神奇的机器然后等着架构设计自动被“加工生产”完毕，因此“需求驱动的架构设计”给架构师的启发不够。 缺点儿什么呢? 答案是，缺“人的因素”、“架构师的因素”! 接下来将不断阐述架构设计实际上是个“质疑驱动的过程”: 需求，被架构师的大脑(而不是自动)，有节奏地引入到架构设计的一波接一波的思维活动中。 例如，作为架构师，当你的架构设计进行到一半时，你可以明显感觉到:这个架构设计中间成果，还需要“我”进一步通过“质疑”引入更多“质量属性”以及“特殊功能场景”来驱动后续的架构设计工作的开展。 在保留“需求驱动的架构设计”所有正确内涵的同时，“质疑驱动的架构设计” 告诉架构师:你的头脑，才是架构设计全过程的真正驱动力。 质疑意识，是架构师最宝贵的意识之一。 至于有的专家提倡的“用例驱动的架构设计”这种观点，则有严重缺陷，3句话足以揭示这一点: 需求=功能+质量+约束 用例是功能需求实际上的标准 用例涉及、但不涵盖非功能需求 "},"ch1/1.2.3.html":{"url":"ch1/1.2.3.html","title":"1.2.3. 多阶段还是多视图？","keywords":"","body":"1.2.3. 多阶段还是多视图？ 架构设计的多视图方法很重要，但是，架构设计方法首先当时多阶段的，其次才是多视图的。 一句话，先做后做--这叫阶段（Phase）,齐头并进--这叫视图(View)。 任何好的方法（不局限于软件领域），都必须以时间为轴来组织，因为这样才最利于指导实践。 架构设计只需要多视图方法，看上去很美，其实并不足够。实际上，大量一线架构师早已感觉到多视图方法的“不足够”。例如，想想投标： 一方面，投标时，需要提供和讲解《方案建议书》，其中涉及架构的内容。 另一方面，团队并行开发是，需要《架构设计文档》提供多方涉众使用。 但是，投标时将的“架构”和并行开发时做为基础的“架构”在同一个抽象层次上吗？绝不可能。前者叫“概念架构”，后者叫“细化架构”。 如果投标失败，细化架构根本没有必要做了。 结论，概念架构设计和细化架构设计，是两个架构阶段，不是两个架构视图。 "},"ch1/1.2.4.html":{"url":"ch1/1.2.4.html","title":"1.2.4. 内置最佳实践","keywords":"","body":"1.2.4. 内置最佳实践 方法不应该是个空框框，应融入最佳实践经验。相信业界很多专家都正朝着这个方向迈进。 ADMEMS方法融入了哪些实践？ 逻辑架构设计的10条经验 质疑驱动的逻辑架构设计的整体思路 基于鲁棒图进行初步设计的10条经验 ADMEMS矩阵方法 约束的4大类型 ... "},"ch1/1.3.html":{"url":"ch1/1.3.html","title":"1.3. ADMEMS方法体系:3个阶段，一个贯穿","keywords":"","body":"1.3. ADMEMS方法体系:3个阶段，一个贯穿 作为方法体系，ADMEMS方法通过3个阶段和一个贯穿，来覆盖“需求进，架构出”的架构设计完整工作内容。 上面的图基本上说明“3个阶段”在整个方法体系中的位置。 具体而言： 预备架构（Pre-architecture）阶段（简称PA阶段） 最大误区：架构师是技术人员不必懂需求 实践要点：摒弃“需求列表”方式，建立二维需求观 思维工具：ADMEMS矩阵等 概念架构（Conceptual Architecture）阶段（简称CA阶段） 最大误区：概念架构 = 理想架构 实践要点：重大需求塑造概念架构 思维工具：鲁棒图、目标-场景-决策表等 细化架构（Refined Architecture）阶段（简称RA阶段） 最大误区：架构 = 模块 + 接口 实践要点：贴近实践的5视图法 思维工具：包图、包-接口图、灰盒包图、时序图、目标-场景-决策表等 3个阶段之间的先后顺序是有极大实际意义，否则就不能称其为“阶段”了。 试想，在PA阶段对需求理解不全面（例如遗漏了需求）、不深入（例如没有发现“高性能”和“可扩展”是两个存在矛盾的质量属性），后续设计怎会合理？ 试想，CA阶段的概念架构设计成果没有反应系统的特点就“冲”去做RA设计，是不是比如会造成更多的设计返工？ “1个贯穿”，指的是对非功能目标的考虑。 "},"ch1/1.3.1.html":{"url":"ch1/1.3.1.html","title":"1.3.1. Pre-architecture阶段：ADMEMS矩阵方法","keywords":"","body":"1.3.1. Pre-architecture阶段：ADMEMS矩阵方法 PA阶段的使命，可以概况为一句话：全面理解需求，从而把握需求特点，进而确定架构设计驱动力。 其中，ADMEMS矩阵居于方法的核心。 "},"ch1/1.3.2.html":{"url":"ch1/1.3.2.html","title":"1.3.2. Conceptual Architecture阶段：重大需求塑造做概念架构","keywords":"","body":"1.3.2. Conceptual Architecture阶段：重大需求塑造做概念架构 概念架构 ≠ 理想化架构。 所以，必须考虑包括功能、质量、约束在内的所有方面的需求。 下图是推荐的概念架构设计的步骤。 "},"ch1/1.3.3.html":{"url":"ch1/1.3.3.html","title":"1.3.3. Refined Architecture阶段:落地的 5 视图方法","keywords":"","body":"1.3.3. Refined Architecture阶段:落地的5视图方法 细化架构是相对于概念架构而言的。 细化架构阶段的总体方法为5视图方法。 许多架构师，言架构必谈OO。在他们的思想里面，认为OO方法已经完整覆盖了架构设计的所有方法和技巧。这种看法，是相当片面的。 弱OO方法已涵盖架构设计的全部，那么5视图方法所涉及的逻辑架构、物理架构、开发架构、运行架构、数据架构，都应受到OO方法的指导，然而并不是这样。 上面图中说提到的物理架构、开发架构、运行架构和数据架构者4个架构视图，分别是面对节点、面对文件、面对控制流和面向Table（或文件）的 -- 也就是说，一般认为这4个架构摄图主要的思维并非OO思维。 另一方面，即使是逻辑架构的设计，也未必是以OO方法为指导的。应该将逻辑架构设计总结为 “面向职责” 更贴近本质。 "},"ch1/1.3.4.html":{"url":"ch1/1.3.4.html","title":"1.3.4 持续关注非功能需求:“目标-场景-决策”表方法","keywords":"","body":"1.3.4 持续关注非功能需求:“目标-场景-决策”表方法 非功能需求不可能是“速决战”，连编码都会影响到性能等非功能属性，更何况概念架构设计和细化架构设计。 ADMEMS方法应对非功能需求的思维工具，目标-场景-决策表可以将架构师的思维可视化出来。 "},"ch1/1.4.html":{"url":"ch1/1.4.html","title":"1.4. 如何解决“6大困惑”","keywords":"","body":"1.4. 如何解决“6大困惑” 那么，如何运用本书解决之前提到的“6个困惑”呢？ 如果，你是一个已经有一定实践经验的架构师，希望更加合理地对系统进行模块切分，请关注“第三部分 Refined Architecture阶段”。你将了解到，划分子系统的4大原则。 职责分离原则 通用专用分离原则 技能分离原则 工作量均衡原则 "},"ch2/":{"url":"ch2/","title":"第2章 Pre-architecture的故事","keywords":"","body":"第2章 Pre-architecture的故事 所谓的“开始就是结局”，要达到什么样的结局取决于什么样的开始，结局就是开始的地方。 -- T.S 艾略特，《四个四重奏》 需求验证的目标是尽可能的暴露问题，而不是证明无错。 -- 徐峰，《软件需求的最佳实践》 没有风险的软件早就被开发完了。 作为架构师，首先要面对的风险就是需求。既要关注功能需求，又要平衡互相矛盾的质量属性需求，还不能遗漏各方面的约束性需求...这，已经成为合格架构师必需的基本功。 接下来，3个真实故事都说明了这一点。 "},"ch2/2.1.html":{"url":"ch2/2.1.html","title":"2.1. “不就是一个MIS吗!”","keywords":"","body":"2.1. “不就是个MIS吗!” 2.1.1 故事： 外籍人员管理系统 公司接单了，一个市级的外籍人员管理系统。 小周被任命为这个项目的架构师。需求分析阶段，小周也参与了。几天之后，小周就开始“轻敌”了，他在一次项目会上说了这么一句话：“这个项目不就是一个MIS吗!” 接下来的工作比较顺利，项目组也算情绪高昂...... 项目组的情绪急转直下，出现在项目接近尾声的一天，客户方的小崔，看着漂亮的“外籍人员信息录入”界面，弱弱的说了一句，“哦，外籍人员的信息，大部分都不是我们录入的，而是来自省局。” 这些问题大了，最棘手的问题是，项目定义的数据库Schema和省级系统的数据库Schema不一致。 若飙车不一致状态，就人为造成了数据格式的不兼容，这是典型的烟囱式应用的做法，为未来可能出现的更多整合要求埋下了障碍； 若参考省级系统的数据模型重新定义数据库Schema，大量代码就必须重写，项目工期必然拖延。 拼命加班...... 2.1.2. 探究：哪些因素构成了架构设计的约束性需求 有人说：“错”的一半是“金”，“败”的一半是“贝”。 故事中暴露的问题看似简单：太大意了，遗漏了重要约束性需求。但试问：下次如何避免？...... 只有我们这样问自己，才算是“败”中求“贝”。 反思结果可以关注第4章 ADMEMS方法的‘约束性分类理论’ "},"ch2/2.2.html":{"url":"ch2/2.2.html","title":"2.2. “必须把虚拟缓存管理裁剪掉”","keywords":"","body":"2.2. “必须把虚拟缓存管理裁剪掉” 2.2.1 故事：嵌入式OS的裁剪 系统软件研究室的新任务启动了，对VxWorks操作系统进行裁剪，并开发专用硬件驱动程序。 团队成员都挺提劲的...... 这天，总工程师要听听进展情况，亲临研究室。当小吴开始汇报对OS虚拟内存管理的“深入理解”时，总工程师的标签有些不大自然。 不久，他打断了小吴，说了这么一句话：“整个系统才有多大内存可用？我们的OS占的内存越多，应用软件可用的内存就越少。所以，必须把OS的虚拟内存管理裁剪掉，直接访问物理内存。” 举“组”震惊，却又深表折服。 2.2.2. 探究：又是约束 架构设计不仅仅要考虑支持功能、满足质量要求，还要重视各种约束性需求。 这个故事中的“内存有限”，就是嵌入式系统设计中常见的约束。 关注约束，要趁早。 "},"ch2/2.3.html":{"url":"ch2/2.3.html","title":"2.3. “都是C++的错，换C重写”","keywords":"","body":"2.3. “都是C++的错，换C重写” 2.3.1. 故事：放弃C++，用C重写计费系统 老郑曾经挺开心。 老郑在某电信软件企业，负责计费系统的架构。最初，他非常重视系统的性能问题，因为他认为：电信领域用户群光，数据量大，所以性能的压力必然会很大。 后来，他们用C++开发的计费系统上线了，用户反映彼此，性能挺高的。 但现在，老郑很懊恼。 原因何在？原来，计费系统一直面临着功能不断改进的压力，整个团队不断致力于提高系统的可扩展性--以便于增加和修改功能。但始料未及的是，可扩展性上去了，性能下来了！ 看着程序里导出都是接口和无处不在的间接、继承，老郑产生了一个危险的念头，都是C++的错，应该用C重写计费系统！ 2.3.2. 探究：相互矛盾的质量属性 互动问题： 问题：某公司以C语言替代C++，重写电信计费系统，因为开发人员引入了太多抽象，导致“可扩展性上去了，性能下来了”。此法可行否？ A. 能解决问题 B. 于事无补，因为C也会过度设计 C. 问题出在Pre-Architecture D. 架构设计中必须分析质量之间的互相影响，制定权衡取舍策略 正确答案：B、C、D 高性能和灵活扩展这两个质量属性之间存在矛盾关系，这就是要害。 上面这张图揭示了更多质量属性之间的“促进”或“矛盾”关系。 我们可以看到：性能和安全性，与其他许多质量属性都是矛盾的。 正确的做法是： 在架构设计之初，就全盘考虑架构设计要重点关注关键质量目标--以老郑为例，性能和可扩展性（当然还会有其他质量属性）都重要。 在第一时间就判断这些“关键质量”之间有没有冲突关系，并制定权衡取舍策略--仍以老郑为例，性能和可扩展性矛盾，性能的优先级更高，谨慎评审提高可扩展性的设计对性能的影响后决定是否采用。 "},"ch2/2.4.html":{"url":"ch2/2.4.html","title":"2.4. 展望“Pre-architecture阶段篇”","keywords":"","body":"2.4. 展望“Pre-architecture阶段篇” 失败的故事，何止3个？透过这冰山一角，我们看到的是一线架构师“把握需求技能的缺失”。 软件架构师不必是需求捕获专家；但他一定应在需求分类、需求折中和需求变更的研究方面的专家，否则他和优秀软件架构师相比就输在“起跑线”上。 接下来，我们来考虑如何建立需求理解的大局观、如何把握需求特点、确定架构设计驱动力。 "},"ch3/":{"url":"ch3/","title":"第3章 Pre-architecture总论","keywords":"","body":"第3章 Pre-architecture总论 凡是预则立，不预则废。 -- 孔子，《礼记.中庸》 业内对架构的讨论沿用了传统思路：如果知道了系统需求，就可以此系统构建架构，这种观点是缺乏远见的...... -- Len.Bass 《软件架构实践（第2版）》 架构设计对系统成败非常关键，那么，什么对架构设计的成败非常关键呢？ 功能需求、质量属性及约束共同决定了架构，对这3类需求的把握是否到位、设计是否对路，是架构设计成败的关键所在！ 然而，业界的现状却是： “架构师就是技术高手”的声音充耳不绝，我们常错误地认为“架构师不必懂需求”。例如，许多不知道业务级需求、用户级需求、开发级需求包含的具体内容，更不懂功能、质量、约束对架构设计的影响如何大相径庭。 只有少数经验深厚的架构师在“拿到”需求之后，会基于业务背景、系统规模、技术趋势、开发团队现状等现实情况，对需求进行理性的、有针对性的权衡、取舍、补充、而在方法一级，Pre-architecture阶段基本是空白的。 期望能够在方法一级为“Pre-architecture阶段”提供较明确的指导。 核心的“四步法”： 需求结构化 分析约束影响 确定关键质量 确定关键功能 "},"ch3/3.1.html":{"url":"ch3/3.1.html","title":"3.1. 什么是Pre-architeture","keywords":"","body":"3.1. 什么是Pre-architecture 我认为，完整覆盖“需求进，架构出”的架构设计方法才是符合需要的。 Pre-architecture就是架构设计的最前期阶段，其工作目标包括：理解需求、建立需求大局观，确定架构设计方向等。 “磨刀不误砍柴工”。如果说“CA”阶段和“RA”阶段是“砍柴”（这两个阶段都对系统进行了某种程度的切分，系统已经不再是“黑盒子”了），那么最初的Pre-architecture阶段就是“磨刀”（此阶段未对系统进行切分，系统还是“黑盒子”）。 "},"ch3/3.2.html":{"url":"ch3/3.2.html","title":"3.2. 实际意义","keywords":"","body":"3.2. 实际意义 Pre-architecture阶段虽然是铺垫性质的阶段，但对架构实践而言意义重大。 3.2.1. 需求理解的大局观 架构师常常面对相互矛盾的需求目标。如果对需求的理解缺乏大局观，那将如何进行需求的权衡取舍？ 重大需求塑造概念架构。如果对需求的理解缺乏大局观，那将如何识别重大需求、特色需求、高风险需求？ Pre-archiecture阶段能帮助架构师建立需求理解的大局观。任何需求都可定位与业务级需求、用户级需求、开发级需求这3个需求层次的某一层，同时也必属于功能、质量、约束这3类需求的某一层。 如此一来，就便于梳理脉络、把握关系。 3.2.2. 降低架构失败风险 对需求理解不透、遗漏需求往往是架构设计失败的重要原因。在你的身边，一定有类似上一章3个真实故事那样的案例。 有一副软件行业自嘲的漫画，讲的是猴子希望得到一串香蕉，收到的却是骨头--这个礼物并不能满足它的真实需求。相信许多人看到这副漫画会苦笑不已。用户经常得不到真正满足他们需求的系统，这已成为整个软件业界一个严峻的问题。 我们无法回避的一个事实：架构师在需求的理解、权衡、取舍和补充这几方面能力严重不足。 从需求转入设计时，因为定制方案过程的复杂性，会激增出大量的衍生需求（针对一种特定设计方案的需求）。设计需求是原始需求的50倍之多。 Pre-architecture阶段将告诉大家，如何告别拙劣的“需求列表”方法（它难道不是遗漏架构影响因素的罪魁祸首吗？），取而代之以ADMEMS矩阵方法。 的确，需求是有结构的！由于ADMEMS的“二维需求观”体现了更复杂的、更本质的需求结构，所以可以帮助架构师更全面地看待需求、避免遗漏重要的非功能性需求，大大降低架构失败的风险。 3.2.3. 尽早开始架构设计 如何尽早开始软件架构设计？这是很多软件企业非常关心的一个问题，因为大家都深感工期的巨大压力。 灵活运用Pre-architecture阶段的方法，有一个额外的好处：能够在需求没有“全面完成”的情况下开始架构设计。 具体而言，为了尽早开始架构设计，软件企业必须做好以下两点： 让架构师参与需求分析工作 实际上，让架构师相对自由的“全程”参与需求分析工作--甚至可以不为任何具体的需求捕获、需求分析、需求文档工作负责 不能被动等待完善的产品需求 建议架构师在参与需求分析工作是，不断运用ADMEMS矩阵等工具对需求进行大局的梳理，只要满足下列3个条件，就可以尽早开始进行架构设计工作。 有了明确的业务需求。必须保证甲、乙双方就建设系统的目标（可能不止一项）达成共识，《愿景文档》经过了正式评审，并明确了投资、工期标准、整合等约束条件。试想，业务需求含糊不清，架构设计方向如何确定呢？ 了解全面的用户需求。也就是说，系统能帮助用户干什么、不能干什么，这个“需求的Scope”已经非常明确了。如果采用了用例技术，则表现为“用例图”是比较完善的，没有明显遗漏 注意用例图和用例规约在需求分析中的实践意义不同，可参考《软件架构设计》一书 有了典型的行为需求。这意味着，大量需求还未明确定义，离提交《软件需求规格说明书》还早。如果采用用例技术，则表现为核心功能的《用例规约》已定义。 3.2.4. 明确架构设计的“驱动力” 架构设计的“驱动力”不就是《软件需求规格说明书》吗？这种观点，只对了一半。 问题1：试想，《软件需求规格说明书》中几乎没有定义非功能性需求（客户也签字了），架构设计师就可以不考虑非功能性需求了吗？ 问题2：试想，需求变更难以避免，如果以所有需求作为架构设计的“驱动力”会是什么结果？ 问题3：试想，《软件需求规格说明书》中照抄了《ISO 9126》中所有的质量属性要求，架构师应该不计成本，不分重点的全部支持吗？ 上面是3个问题，都是日常工作中常见的问题，都说明架构师还需要关注其他很多因素，最终或添加、或减少、或折衷，理性的确定真正的架构设计“驱动力”。 具体而言，Pre-architecture阶段将告诉我们不辱使命的方法： 分析业务需求和约束背后的衍生需求--针对问题1. 发现遗漏需求--针对问题1. 确定关键功能--针对问题2. 确定关键质量--针对问题2. 权衡质量属性之间矛盾关系--针对问题3. "},"ch3/3.3.html":{"url":"ch3/3.3.html","title":"3.3. 业界现状","keywords":"","body":"3.3. 业界现状 既然Pre-architecture阶段如此重要，业界现状如何呢？ 很遗憾，业界对Pre-architecture阶段普遍不够重视。相反“架构设计唯靠经验”、“架构设计目标不变”等错误观点比较常见。 我们头脑中的“位置”是有限的，如果错误的认知占据了主导位置会导致实践偏差，必须防止。 3.3.1. “唯经验论” 和“架构师不必懂需求”的误解相比，“唯经验论”已经有所进步了。这种观点认为，架构师纯粹凭借经验，发现需求的遗漏、权衡需求之间的矛盾、确定架构设计的重点目标。 必须承认，经验对架构设计很重要，但“唯经验论”依然是错误的。 因此，世界上并不存在两个完全相同的想，不同的项目在功能需求、质量属性，以及约束这3方面必然存在差异。 于是，架构师不仅应具有一定经验，还必须掌握超越具体项目的、更具有意义的方法和技能。 3.3.2. “目标不变论” 架构设计的目标不是一成不变的，基于此认识，ADMEMS方法在Pre-architecture阶段的“确定关键质量”环境提供了专门的指导。 “架构设计目标不变论”是错误的。 例如，有人认为： 我们必须牢记架构设计的总体目标，可概况为以下几点。 最大化的重用...... 尽可能的简单明了...... 最灵活的扩展性...... 首先，若架构设计的目标真能概括为不变的“几点”，那可算是架构师的福音了。 但实际上，架构设计的目标必然会随着领域不同（如航天航空、电信、电子政务）、规模不同（如项目、产品、平台）、条件不同（如工期、预算、标准）而变化。 其次，为重用、简单、可扩展都加了“最”（而不是权衡折中），不符合架构设计的现实，更何况“灵活”和“简单”之间常常存在矛盾。 3.3.3. 需求分类法的现状 软件行业处在不断发展变化中，软件需求分类法就是一例。当前，业界影响最为广泛的需求分类法将需求分为3个层次。 图片来源：《软件需求》 这种需求分类法的最大好处是明确了不同层次之间的跟踪关系--业务需求->用户需求->功能需求。从而建立了需求分析的主要脉络，非常有意义。 但是对以架构师来说，这种需求分类法中的“约束条件”太过狭义了，没有反应“架构设计必须面对来自业务环节、使用环境、构建环境、技术环境的4大类约束”这一现实情况。 再例如，RUP提倡的需求分类法也包含3个层次：需要（Need）、特性（Feature）、软件需求。 这类分类法也是主要为需求分析工作服务的，它除了非常倚重用例技术之外，还有一个明显特点--Feature。 以特性（Feature）技术作为从需要（Need）想软件需求过过渡的跳板，是解决需求分析中“从需求想软件需求跨度过大”问题不错的选择，这一点已经受到很多实践者的认同。 但是，这个方法中用例的地位过分突出了，又由于“用例涉及但不涵盖非功能需求”的性质，不少实践者遗漏非功能需求的常见问题也就不难解释了。 最后，顺便指明上述两种“需求层次论”的对应关系，此问题令不少实践者困惑。 3.3.4. 需求决定架构的原理还需继续归纳 不懂不同需求分布如何影响架构，就难以进行理性的架构设计，难免“拍脑袋”决策，关于需求决定架构原理，业界当前的认知状况如下： 功能影响架构原理，研究的最透彻 质量影响架构的原理，也有基本共识 约束影响架构的原理在很大成图上被忽视了 "},"ch3/3.4.html":{"url":"ch3/3.4.html","title":"3.4. 实践要领","keywords":"","body":"3.4. 实践要领 问题是方法之父。不怕有问题，就怕发现不了问题。 3.4.1. 不同需求影响架构的不同原理，才是架构设计的基础 当前业界，大多数架构师都认同“需求决定架构”，但对需求“如何决定”架构还知之不深。 请各位架构师问自己这样一个问题：需求决定架构，真的是这么简单吗？ 如果真的这么简单，为何“我”常常对需求已“心知肚明”，却依然对架构设计“一筹莫展”呢？ 答案是：“需求决定架构”是对的，但不同需求影响架构的不同原理，才是架构设计思维的基础。 “人类知识和人力权利归于以：因为凡是不知原因时，即不能产生结果。......而凡是在思辨中为原因者在动作中则为法则。” -- 哲学家培根 任何一项功能都是有一条特定的“职责协作链”完成的。 作为完整的软件系统，它在支持每一个具体功能时，都必然涉及软件不同“部分”之间的相互配置。系统控制权在这些不同的“部分”之间的来回传递，形成一条“职责协作链”，可以完成非常复杂的功能。 而质量，是完善架构设计的驱动力，不考虑质量的系统是无法走出实验室的。 基于中间设计成果进一步质疑是其中基本的“思维方式” 例如：如果只考虑功能，“页面缓存”的设计就永远不会被引入，它是质疑性能、调整设计的结果。 至于约束，则有不同的具体方式影响着架构设计 直接制约设计决策的约束。例如，“系统运行与Unix平台之上”作为一条约束，架构师直接遵守即可。 转化为功能需求的约束。例如，“本银行系统必须严格执行人民银行统一规定的利率”是一条约束，但分析后发现，正是它引出了一条功能需求：即必须提供调整利率设置的实用功能。 转化为质量属性需求的约束。例如，有经验的系统分析员发现了一条重要约束：“任职于各储蓄所和分理处的柜员，计算机水平普遍不高”。由此，未来的系统必须具有很高的易用性（否则不会用）和鲁棒性（否则可能会把系统搞瘫痪了）就非常必要了。 3.4.2. 二维需求观 观念是行为的向导，有什么样的观念存在，就有怎样的行为方式产生--突破拙劣观念的意义就在于此。 作为架构师，如果在你的观念中，需求是一个散乱无序的“列表”，面对复杂系统时就会非常被动。需求列表这种贴着“简单”这个“招人待见”标签的方法以及影响、并正在继续影响着许多一线架构师。 3.4.3. 关键需求决定架构，其他需求验证架构 有经验的架构师，懂得在实践中运用“关键需求决定架构”的理念。 功能需求做减法。在所有功能中挑选一个“关键功能子集”，作为“架构设计驱动力”的第一部分。 质量需求做减法。根据系统所在领域特点及系统规模等因素，确定架构设计重点支持哪些质量属性，作为“架构设计驱动力”的第二部分。 约束需求做加法。充分考虑需求方及业务环境因素、用户群及使用环境因素、开发方及构建环境因素、业界当前技术环境因素等“4类约束”，将之作为“架构设计驱动力”的第三部分。 3.4.4. Pre-architecture阶段的4个步骤 Pre-architecture阶段对整个架构设计工作非常重要，它担负着建立需求大局观、把握需求特点、确定架构设计驱动力的责任。 首先，将多而杂的架构影响因素梳理脉络、建立全面有序的理解。 然后，分别针对约束、质量、功能这3类需求开展相应工作。 分析约束影响，识别隐含需求 确定关键质量，明确关键质量之间的优先级 确定关键功能，便于更有针对性的分配有限的架构设计时间 "},"ch4/":{"url":"ch4/","title":"第4章 需求结构化与分析约束影响","keywords":"","body":"第4章 需求结构化与分析约束影响 “心念不同，判断力自然不同。” -- 严定道，《格局决定结局》 全面认识需求，是生成出高质量软件所必须的“第一项修炼” -- 温昱，《软件架构设计》 Pre-architecture阶段包括4个步骤，咱们先讲讲前两步。 第1步，需求结构化 第2步，分析约束影响 "},"ch4/4.1.html":{"url":"ch4/4.1.html","title":"4.1. 为什么必须进行需求结构化","keywords":"","body":"4.1. 为什么必须进行需求结构化 需求是有结构的。 许多实践者不懂这一点，更不知道如何“主动运用”这一点。在他们眼中，架构设计要应对的需求往往是又多又乱的，而且遗漏了关键需求也发现不了...... 相反，有经验的架构师懂得运用需求的结构。他们能够将复杂的需求集合梳理得紧紧有条，为进一步分析不同需求之间的联系（作为权衡折中的依据）、识别遗漏的重要需求打下坚实基础。 Pre-architecture阶段要求进行需求结构化，这代表着ADMEMS方法更贴近一线架构设计的真实实践。 通过形象的“物体归类”的隐喻可以嘉盛对需求结构化工作的理解。 "},"ch4/4.2.html":{"url":"ch4/4.2.html","title":"4.2. 用ADMEMS矩阵方法进行需求结构化","keywords":"","body":"4.2. 用ADMEMS矩阵方法进行需求结构化 那么，需求结构化要怎么做呢？ 决不能认为《软件需求规格说明书》就是需求的全部 运用ADMEMS矩阵方法 4.2.1. 范围：超越《软件需求规格说明书》 首先，需求文档常常不够全面，所有有经验的架构师都重视需求文档，但不应该“唯需求文档论”。 其次，需求变更经常发生，“依赖且仅依赖需求文档”不够聪明，使架构设计工作非常被动。 既然架构师必须“对需求进行理性的、有针对性的权衡、取舍、补充”，那么“作为架构设计驱动力的需求因素”和“供甲方确认的《软件需求规格说明书》”之间就必然不能“划等号”。 所以，架构师要通过需求结构化真正全面的“鸟瞰”需求大局，就必须超越《软件需求规格说明书》 还有一个重大意义在于，只有摆脱了对《软件需求规格说明书》的“呆板依赖”，才有可能尽早开始架构设计（参见3.2.3. 尽早开始架构设计）。 4.2.2. 工具：ADMEMS矩阵 矩阵，是很多著名方法的核心。 例如：制定公司层战略的方法之一是“波士顿矩阵”，“波士顿矩阵”又称为“市场增长率-相对市场份额矩阵”。 “ADMEMS矩阵”，也称为“需求层次-需求方面矩阵”。 需求层次分析和解释 业务级需求：包含客户或出资者要达到的业务目标、预期投资、工期要求、以及要符合哪些标准、对哪些遗留系统进行整合等约束条件 用户级需求：用户使用系统来辅助完成哪些工作？对质量有什么要求？用户群及所处的使用环境有什么特殊要求? 开发级需求：开发人员需要实现什么？开发期间、维护期间有什么质量考虑？开发团队的哪些情况会反过来影响架构？ 需求的三个层次，是站在“不同层次的涉众提出需求所站的立场不同的角度”，将需求划分为三种类型。 另外，需求还需要从不同的方面进行考虑。 例如，一个网上书店系统的功能需求可能包括“浏览书目”、“下订单”、“跟踪订单状态”、“为书籍打分”等，质量属性要求包括“互操作性”和“安全性”等，而“必须运行在Linux平台之上”属于约束性需求。 忽视质量属性和约束性需求，常常导致架构师设计最终失败。 从“需求定义了直接目标还是间接限制”的角度，把需求划分为3中类型，这就是需求的3个方面： 功能需求：更多体现各级直接目标要求 质量属性：运行期质量 + 开发期质量 约束需求：业务环境因素 + 使用环境因素 + 构建环境因素 + 技术环境因素 一句话，需求是有结构的。而且，需求的结构绝不是“List”，而应该是“二维数组”。 结构化是控制复杂度的好办法。 进行需求结构化之后，会感觉“需求变少了”--其实，需求并没有变少，但复杂度却得到了控制。 另外，进行结构化之后，最大的好处是，可以比原来更轻易发现遗漏需求。 方法的运用，可以参考4.7. 大型B2C网站案例：需求结构化与分析约束影响 "},"ch4/4.3.html":{"url":"ch4/4.3.html","title":"4.3. 为什么必须分析约束影响","keywords":"","body":"4.3. 为什么必须分析约束影响 风险有个烦人的特点：一旦你忘了它，它就会找上门来制造麻烦。 背鳍下面是不是一条鲨鱼？约束性需求中，是不是潜藏了风险因素？ 对于架构设计而言，来自方方面面的约束性需求中潜藏着大量风险因素。 "},"ch4/4.4.html":{"url":"ch4/4.4.html","title":"4.4. ADMEMS方法的“约束分类理论”","keywords":"","body":"4.4. ADMEMS方法的“约束分类理论” 分析约束影响应该怎么做？ 我们先看看这些约束来自“哪些涉众”？ 4类约束在ADMEMS矩阵中的位置清楚表明：业务环节、使用环境、构建环境应分别考虑客户、用户、开发者3类涉众，而技术环境与上述3类涉众都有关系 ADMEMS矩阵参见4.2.2 用ADMEMS矩阵方法进行需求结构化-工具：ADMEMS矩阵 只有把握住涉众来源，才便于发现并归纳涵盖广泛的约束因素，也有利于针对性地进行交流，还可跟踪对约束的支持是否令涉众满意。 第一，来自客户或出资方的约束性需求 架构师必须充分考虑客户对上线时间的要求、预算限制，以及集成需要等非功能需求。 客户所处的业务领域是什么？有什么业务规划和业务限制。 是否需要关注相应的法律法规，专利限制？ ...... 第二，来做用户的约束性需求 软件将提供给何阶层用户？ 用户的年龄段？使用偏好？ 用户是否遍布多个国家？ 使用期间的环境有电磁干扰、车船移动等因素吗？ ...... 第三，来自开发者和升级维护人员的约束性需求 如果开发团队的技术水平有限（有些软件企业甚至希望通过招聘便宜的程序员来降低成本）、磨合程度不高、分布在不同的陈那个是，会又和影响？ 开发管理方面、源代码保密方面，是否需要涉及？ ...... 第四，也不能遗忘，业界当前技术环境本身也是约束性需求 技术平台、中间件、编程语言等的流行性认同度、优缺点等。 技术发展的趋势如何？ ...... 架构师应当直接或（通过需求分析员）间接的了解和掌握上述需求和约束，并深刻理解它们对架构的影响，只有这样才能设计出合适的软件架构。 例如，如果客户是一家小型超市，软件和硬件采购的预算内都是很有限，那么你就不宜采用依赖太多昂贵中间件的软件架构设计方案。 "},"ch4/4.5.html":{"url":"ch4/4.5.html","title":"4.5. Big Picture:架构师应该这样理解约束","keywords":"","body":"4.5. Big Picture:架构师应该这样理解约束 另外，还有一个重要的基础问题，太多的架构师对约束的理解都过于零散，影响了系统化思维。 一句话：约束是架构设计的上下文。 没有全局观念就不可能成为架构师，”约束是架构设计要解决的问题的上下文“是一个犀利的理解，揭示了 ”软件需求 = 功能需求 + 质量 + 约束“背后更深层层次的规律。 如果忽视了上下文对架构设计的限制，最终的架构设计就是不合理的，甚至是不可行的。 举个生活中的例子--设计大桥。建筑师必须关注以下4类约束的影响，合理规划大桥的设计方案。 考虑商业环境因素：以促进两岸的经济交往为主（这会影响大桥的选址），同时也希望大桥在建设在一定程度上起到提升城市形象的作用。 考虑使用环境因素：水上交通繁忙，二期常有大吨位船只通过，大桥建成投入使用期间不能对此造成影响。 考虑构建环境因素：这是一条很大的河流，水深江阔，为造桥而断流几个月是绝对不可行的。 考虑技术环境因素：斜拉桥因其跨度大等优点，当前广为流传，并且技术也相当成熟...... "},"ch4/4.6.html":{"url":"ch4/4.6.html","title":"4.6. 用ADMEMS矩阵方法辅助约束分析","keywords":"","body":"4.6. 用ADMEMS矩阵方法辅助约束分析 分析约束影响在需求结构化的基础上，充分考虑需求方及业务环节因素，用户群及使用环境因素、开发方及构建环境因素、业界当前技术环境因素等”4类约束“，并分析约束印象、识别约束背后的衍生需求。 从本质上讲，分析约束影响就是分析各个需求项之间的关系，并发现被遗漏的需求。所以将需求”化杂乱为清晰“的正交表可以作为分析约束影响的基础--即在需求项清晰定位的前提下，找到不同需求之间的关系，发现遗漏需求。 ADMEMS矩阵方法应用法则有两个。 推导法则：从上到下，从右到左。 查漏法则：重点是质量属性遗漏。 "},"ch4/4.7.html":{"url":"ch4/4.7.html","title":"4.7. 大型B2C网站案例：需求结构化与分析约束影响","keywords":"","body":"4.7. 大型B2C网站案例：需求结构化与分析约束影响 像Amazon这样大型的B2C网站，架构的起步阶段应如何规划呢？下面看看ADMEMS方法的“表现”。 4.7.1. 需求结构化 通过ADMEMS矩阵（需求层次-需求方面矩阵），有助于高屋建瓴的把握复杂系统的需求大局。 先来梳理一下业务级的需求。 用户级需求，要特别注意挖掘来自“用户及使用环境”的约束，也别忘了开发方的因素。 4.7.2. 分析约束影响（推导法则应用） 接下来分析约束影响。 基于ADMEMS矩阵应用推导法则规律十分明显：隐含需求（或遗漏需求）是通过 “从上到下” 或 “从右到左” 的脉络被发现的。考虑到公司的中远期法则（B2C业务从图书扩展到各类商品），以及近期商业策略（投入资金2000万）的限制，必须制定“网站发展路线图”--而这对架构而言属于“开发级约束”。 接下来，我们利用类似的思维来理解不同需求之间的联系，这样你不会再觉得需求是“一盘散沙”了。 4.7.3. 分析约束影响（查漏法则应用） 另外，还要主动运用查漏法则。例如，我们发现至今对质量的重视还不够（实践一线经常出现此情况），于是开始“查漏”：方方面面的约束背后藏着哪些必须强调的质量属性要求呢？ 例如，如此多的质量要求，比如要提高系统的互操作性...... "},"ch4/4.8.html":{"url":"ch4/4.8.html","title":"4.8. 贯穿案例","keywords":"","body":"4.8. 贯穿用例 4.8.1. PASS系统背景介绍 PASS系统的全称是：合理用药监测系统（Presription Automactic Screening System）。通过全面部署PASS系统可以促进医院的用药合理化、规范化、降低医院的医疗事故率，还有利于管理部门高效全面的掌握医疗一线的用药情况，及早发现问题域解决问题。 PASS系统的主要功能: 医生 用药及时监测 注意事项打印 管理员 身份管理 用药规则数据的更新 管理者（如院长） 多种方式的信息查询 多张报表 外部系统的整合 药政部分的信息上报 用药规则数据库的自动更新 ...... 4.8.2. 需求结构化 将“功能列表”等同于“全部需求”根本不是架构师的应有做法。相反，为了全方位、多角度的把握需求，应当重视并运用“需求的结构”。 4.8.3. 分析约束影响 下面逐一分析约束因素的潜在影响。 首先是业务级需求因素的影响分析。例如，既然药品的种类繁多、用药规则的数量也很大，就应该设法避免每家医院都重复用药规则--于是决定“省级集中提供用药规则的定义和更新支持”（这其实是业务流程一级的一项需求）。 "},"ch6/":{"url":"ch6/","title":"第6章 概念架构的故事","keywords":"","body":"第6章 概念架构的故事 胜兵先胜而后求战，败兵先站而后求胜。 -- 孙子，《孙子兵法 . 形篇》 人们常常使用战术，而忽略了战略。战略要求从大局上把握整个架构与设计......架构错误的代价非常高。 -- Stephane Faroult, 《SQL语言艺术》 架构新手和有经验的架构师的区别之一，在于是否懂得，并能有效的进行概念架构设计。作为架构新手，尤其害怕碰到自己没有做过的系统：系统较大时，一点祭出“架构 = 模块 + 接口”的发布却不太奏效，架构新手就往往乱了阵脚。想法，有经验的架构师不会一上来就关注与如何定义“接口”，他们在大型架构设计的早期比较注重识别重大需求、特色需求、高风险需求，据此来设计概念架构。 另外，概念架构设计还是投标及售后工作的有力武器。金牌售前和普通售前的一个重要区别是，能否清晰的讲解概念架构，并借此说明 “客户关系的价值如何实现、担心的问题如何解决”。 接下来，通过两个发生在身边的故事，来一窥上述不同工作（架构设计、投标、售前）背后的幕后英雄--概念架构。 "},"ch6/6.1.html":{"url":"ch6/6.1.html","title":"6.1. 一筹莫展","keywords":"","body":"6.1. 一筹莫展 日落西山，夜幕徐徐降临，遍布这个城市各个角落的写字楼陆续亮起了灯...... 灯下，有我们这些软件从业者加班的身影。小张，还有老王，就是故事的主角。 6.1.1. 小张，以及他负责的产品 加班人： 小张 职业概况： 28岁，某医疗软件公司的程序高手，这不，公司刚刚提拔他作了架构师。 加班缘由： 他正负责一个名为“合理用药监测系统（Prescription Automatic Screening System, PASS）”的软件的架构设计。由于以前没有做过类似的产品，小张压力很大。按说，压力大对软件行业的人来说早已是家常便饭了，但要命的是，小张有点不知所措了..... 晚上7点，小张坐在桌前。 在心中，小张对架构的理解可以概况成一个公式：“架构 = 模块 + 接口”。 成为架构师伊始，他还专门用“接口”和“架构”作为关键词在网上搜了一把，看看别人的观点是否和他相同。结果让他非常满意，网上的一些观点和他的观点惊人的像是。例如网上有观点认为： “当你发现可以越来越灵活的使用接口时，那么你就从程序员升级成架构师了。 在一些大型项目或大型公司里，都有架构师编写出系统接口，具体的实现类交给程序员编写。公司越大，这种情况月明显，所以在这些公司里做开发，我们可能都不知道编写出的系统是个什么样子，每天的工作可能就是做‘填空题’了” 但是，小张注定要在这个加班的夜晚，悄然开始重新认识“架构 = 模块 + 接口”这句话了。 一方面，小张已在“模块 + 接口”一级做了些设计努力。另一方面，小张也感觉到问题所在了：这个PASS系统未来不可能仅仅包含一个可执行单元！相反，医生需要的功能要嵌入医院信息管理系统（HIS系统）的医生工作站中，管理员的功能需要其他方式，Server要独立出来...... 小张当下的感觉，应了一句小品台词--“有点乱了”。是呀，连PASS系统到底将包含几个”可执行单元”都没有搞清楚，就考虑“模块 + 接口”一级的设计，的确有些武断了。 晚9点，思路不畅的小张开始上网搜资料。 在网上搜资料时，小张总是相当有耐心。他深知，虽然网上的资料非常多，但真正能启发思路的资料往往只在最后时刻出现。 小张移动鼠标，右击任务栏上的“浏览器”按钮，点击了“关闭组”菜单，者表示小张任务查到的资料启发不大，准备重头来过--在今晚已经是第3次了。 他若有所思，在搜索框中输入了3个关键词：”架构“、”大局“、”不拘小节“。一篇博文引起了他的注意： 概念性架构就是对系统设计的最初构想，就是把最关键的设计要素和交互的机制确定下来，然后考虑具体技术的运用，设计出实际架构。 概念性架构应该抓大局、不拘小节。 虽然概念性架构都跳不出”架构 = 组件 + 交互“的基本定义，但它们描述架构的具体方式还是有比较大的差异：有的重视逻辑层，有的重视物理层，有的通过隐喻表明机制，有的看起来似乎就是一些设计元素的组合。不同的概念性架构图中，“连接”代表的含义千差万别：有的是依赖方向，有的是控制方向，有的是数据流向，一次，必须根据具体情况而定。 小张仔细的揣摩每句话的意思。 不知不觉，时钟指向了11点，小张坐不住了。 他在办公室来来回回的踱步，表情时而郁闷，时而欣喜...... 最后，小张把文章打印了一份，塞在包里，离开了办公室。 6.1.2. 老王，后天见客户 加班人： 老王 职业概况： 35岁，某电信软件企业网管软件事业部的售前工程师。老王从事软件行业有10年了，一直做软件开发，一年前开始做售前相关工作。 加班缘由： 后天，他要到客户单位，做网管软件新产品的介绍。这个客户非常重要，二期公司对这一单志在必得，老王不敢懈怠。 老王看着公司草草拼凑出来的售前PPT有点发愁，架构方面的描述主要就是一个概念架构图，如图所示，这种架构描述根本没有体现产品特点，叫做售前的如何说服客户呢？ “我要不说明，谁看了这个概念架构能知道它是个网管系统，而不是电子商务或其他什么系统？”老王愤愤的想。 "},"ch6/6.2.html":{"url":"ch6/6.2.html","title":"6.2. 制定方针","keywords":"","body":"6.2. 制定方针 小张，还有老王，昨天都加班到很晚，但今天他们依然按时来到单位。 每天的太阳都是新的。对开朗的人来说，昨天的烦恼不算什么，根本不会影响他们今天工作的热情和创造力。 6.2.1. 小张：我必须先进行概念架构的设计 小张在座位上坐定，破例没有查收邮件，更没有上网看新闻。他做的第一件事是，拿一张干净的A4纸铺在桌上，开始逐条例举PASS系统需求中对架构产生最关键影响的“5大因素”。 “我作为架构师应该做什么呢？”小张脑中快速的思考着，“是一层不变的继续‘模块 + 接口’一级的设计，还是先针对主要风险确定架构大局，而后在进一步考虑它呢？” 经过一系列的反思，小张认为对PASS系统直接进行“模块 + 接口“一级直接进行合计存在以下两个严重的问题： 针对”单独的可执行单元“形式的系统，或许可以直接按”模块 + 接口“方式展开架构设计，而现在的PASS系统显然不是。 如何通过模块切分和接口定义来支持团队开发，还算不上当前的主要矛盾；上面分析的”5大因素“才是当前的主要矛盾。 主要矛盾决定事态发展。想清楚了架构设计的主要影响因素，小张微微有些高兴。他认真的把他的决定写在笔记本上（还特意加了一句注解说明），生怕忘了似的： 首先根据对架构产生最关键影响的”5大因素“进行概念设计。 注：概念架构不关心明确的接口定义。 此时的小张俨然像是在战场上做出了重大战略决策的将军。 6.2.2. 老王：清晰的概念架构，明确的价值体现 9点整，老王悠悠的走进办公室。他总是如此准时，在这个经常堵车的城市，可算是一个小小的迷了。 他做的第一件事是，往茶杯里放入了几十粒上好的枸杞，倒上开水。上午枸杞，下午绿茶，老王习惯了。老王就是有这个本事，根本看不出来昨晚加班是多么的一筹莫展。老王或许不知道，这种弄闲庭信步的气质恰恰是他日后越来越成功的关键。 温伯格讲：“力量是一种关系”。老王很欣赏这句话。 音乐有力量吗？不一定！它可以“催”人泪下，但也可以是对“牛”弹琴。 你的产品很好吗？不一定！只有满足客户需求的产品才是好的产品，所以做售前的决不能自我感觉良好。 胜利远远还没有”在望“，但端着茶杯楞一会儿神儿的老王已成竹在胸。 后天的重点不是在讲纯技术，而是抓住客户关系的价值和担心的问题，并在一个小时之内清晰的勾画出产品的相应策略。 "},"ch6/6.3.html":{"url":"ch6/6.3.html","title":"6.3. 柳暗花明","keywords":"","body":"6.3. 柳暗花明 行必果，小张和老王忙开了。 有人说，”行动果断是一种美德。“，其实，他们都觉得”行动果断“算不上什么美德，毕竟，老板是要看结果的--不行动，就永远没有成功的可能。 6.3.1. 小张：重大需求塑造概念架构 小张将”分析需求特点“所归纳出来”5大因素“作为概念架构设计的目标。 考虑设计目标中的1、2和3这三点，小张得到了概念架构中间结果。 接下来，小张继续深入概念架构的设计。他想：上述设计目标中的第4点和第5点还没有相应的对策，这无疑意味着具体的风险，因为从现在的设计来看根本无法做到“较高的持续可用性”。而对于”降低HIS系统差异带来的影响“也没有任何针对性的设计决定。 经过一番考虑之后（具体思考过程请参考”目标-场景-决策表“方法的讲解），小张做出了下面的概念架构设计决定。为了提高持续可用性，在设计中引入了故障转移集群。 针对”现行HIS系统差异很大、实现技术不统一“的约束性需求，重点考虑了如何提高重用性以降低开发及维护成本。采用的策略是：引入独立于具体HIS意思工作组的”PASS系统医生模块通用SDK“，它包括了”嵌入到医生工作站的软件模块“的所有特定HIS系统无关部分，使支持HIS的工作量降到最低。 6.3.2. 老王：概念架构体现重大需求 首先，老王通过一些途径了解了客户对网管软件采购的具体要求，例如可升级性、可方便支持新设备等。 接下来，老王从公司的服务器上下载了新的网管产品的各种文档，开始快速浏览。他在找售前材料商遗漏的，却至关重要的产品特色。他敏感的发现，有如下几点比较重要： 强大的API支持，便于二次开发。 基于SPI（服务编程接口）的可扩展设计。 最终，老王利用FAB分析法，轻车熟路的绘制了更能体现新网管产品价值的概念架构。此架构对客户关系的”可升级性、可方便支持新设备“等要求有着较明确的支持。 "},"ch6/6.4.html":{"url":"ch6/6.4.html","title":"6.4. 结局与经验","keywords":"","body":"6.4. 结局与经验 天气，风和日丽。 小张和老王的心情都特别好。虽然统计数据显示，这个城市一年有上百天都是蓝天，但他两总觉得今天的天蓝的特别漂亮。 6.4.1. 小张：概念架构时设计大系统的关键 小张负责的PASS产品成功上市了，市场反映很不错。 回顾过往的辛苦，小张觉得很有收获，特别是切实体会到了概念架构设计对大系统成败的关键作用。他的工作笔记，也因此备受珍爱，其中一页写到： 万事开头难。 当要设计的软件系统非常复杂时，直接设计实际架构往往有困难。实际的软件架构设计过程是，一部应先进行概念架构的设计，把嘴关键的设计要素和交互机制确定下来，概念架构是对系统设计的最初构想，但绝不是无关紧要的；相反，它对大型系统的成功非常关键。架构师在设计概念架构时，必须牢牢抓住重大需求、特色需求、高风险需求，有针对性的确定设计策略。 反过来讲，一个产品与类似产品在架构上的不同，其实在概念架构设计时就大局已定了。 概念架构一级的设计更重视”找对路子“，它往往是战略而不是战术，它必将策略化而未必全面，它必将强调重点机制而不一定非常完整。 在概念架构设计中，不关注明确的接口定义；之后才是”模块 + 接口“一级的设计。对大型系统而言，这一点恰恰是必需的。 6.4.2. 老王： 概念架构是售前必修课 老王成功了，最终这家客户采购了老王所在公司的新一代网管软件。 回顾这看似平常的一单，老王不无收获： 第一，概念架构是售前的必修课，所谓金牌销售，必备的能力之一是：是否能清晰的讲解概念架构，并借此说明”客户关系的价值如何实现，担心的问题如何解决“。 第二，成功的售前必须关注客户。力量是一种关系，通过FAB分析法找到产品之于客户的价值所在，是售前准备的重点之一。 第三，售前PPT不能千篇一律。作为公司，制作标准的售前PPT是为了避免一般售前人员不得要领，或者讲错理念，真正的专家级售前不应受到”标准售前PPT“的限制。 "},"ch7/":{"url":"ch7/","title":"第7章 Conceptual Architecture总论","keywords":"","body":"第7章 Conceptual Architecture总论 ”Use Case驱动“的观点既有积极意义，也有不利影响。从积极的方面看，Use Case这种需求描述方式确实有助于分析模型，设计模型，实现模型和测试模型的建立.....但是从另一方面看，OOSE对Use Case的依赖程度超出了它的实际能力。 -- 邵伟忠， 《面向对象的系统设计》 顶级设计者在设计中并不是按部就班地采用自顶向下（或自底向上）的方法，而是着眼于权重更大的目标。这些目标通常是难点问题，设计者不能轻易地看出这些问题的解决方案。为了得到整个的设计方案，设计者必须先致力于难点的设计并消除其中的疑惑。 -- Robert L. Glass, 《软件工程的事实与谬误》 概念架构是大型系统架构设计成败的关键。 "},"ch7/7.1.html":{"url":"ch7/7.1.html","title":"7.1. 什么是概念架构","keywords":"","body":"7.1. 什么是概念架构 下面是宏伟的金门大桥，这么复杂的架构，桥梁架构师是怎么“开始设计”的呢？ 答案是：概念架构（Conceptual Architecture）。下图展示了斜拉桥的概念架构示意图。由此图可以看出，概念架构高屋建瓴的给出高层解决方案：索塔负责承重，斜拉索吊起刚性梁。 下面，来看看软件行业（来自Dana Bredemeyer等专家）中概念架构的定义： 概念性架构界定系统的高层组件，以及它们之间的关系。概念性架构意在对系统进行适当分解，而不陷入细节。借此，可以与管理人员、市场人员、用户等非技术人员交流架构。概念性架构规定了每个组件的非正规约及架构图，但不涉及接口细节。(The Conceptual Architecture identifies the high-level components of the system, and the relatiooonships among them. Its purpose is to direct attention at an appropriate decomposition of the system without delving into details. Moreover, it proovides a useful vehicle for coommunicating the architecture to non-technical audiences, such as management, marketing, and users. It consists oof the Architecutre Diagram (without interface detail) and an informal component specification for each component.) 根据定义，我们注意到如下几点： 概念架构满足“架构 = 组件 + 交互”的基本定义，只不过概念架构仅关注高层组件(high-level components)。 概念架构对高层组件的“职责”进行笼统的界定（informal specification），并给出了高层组件之间的相互关系(Architecture Diagram)。 概念架构不应涉及接口细节(withouot iinterface detaiil)。 "},"ch7/7.2.html":{"url":"ch7/7.2.html","title":"7.2. 实际意义","keywords":"","body":"7.2. 实际意义 不同的系统架构经常不同。但请继续追问自己两个极具价值的问题。 不同系统的架构 ，为何不同？ 架构设计中，应何时建立架构大方向的不同？ 第1个问题的答案：需求不同，所有架构不同；当然，“需求”不是单指“功能需求”，而是包含了功能、质量、约束等方面。 第2个问题的答案：进行概念架构设计时应确立架构大方向。架构设计跪在有针对性，概念架构针对重大需求、特色需求、高风险需求的要求，给出高层次的解决方案--这就是概念架构最重要的意义。 另外，所谓“备选架构方案”经常是概念架构一级的，有助于架构的对比分析、评审优化。 最后，概念架构为投标、售前、市场宣传等工作提供强力支持，所以，概念架构也是售前和市场人员的“必修课”。 "},"ch7/7.3.html":{"url":"ch7/7.3.html","title":"7.3. 业界现状","keywords":"","body":"7.3. 业界现状 7.3.1. 误将“概念架构”等同于“理想架构” 主动思考以下两种说法是否正确： 架构设计是功能需求驱动的，对吗？ 架构设计是用例驱动的，对吗？ 说法1，错误。因为，架构设计的驱动力 = 功能 + 质量 + 约束。 说法2，同样错误。用例技术是功能需求实际上的标准，用例技术涉及，但无法全面涵盖非功能需求。所以，说法2和说法1并无本质区别。 因此，“用例驱动的架构设计”的做法颇值得商榷。纵观业界，有不少书持“用例驱动的架构设计”的观点。比如《Rational 统一过程：实践者之间》一书中有一节名为“是用哪个架构重要用例来驱动架构设计”，其中写道： 对架构重要的用例驱动了架构设计。对于大多数系统而言你通过选择仅仅20%至30%的用例，然后设计、实现并测试每个用例的一两个场景，就能降低大部分技术风险，并驱动欧诺个架构的实现。为了实现某个特定用例，你要识别出那些支持用例的软件元素。 实际上，实践者误认为概念架构就是只考虑功能设而设计出来的理想化架构，其实，这是关于概念架构的最大误解，在实践中应当注意避免。 7.3.2. 误把“阶段”当做“视图” “视图”是架构领域的热门词汇，但很不幸，“视图是个筐，什么都往里面装” -- 我们的同行经常犯这种错误。例如，《编程匠义 -- 编写卓越代码》一书中错误的认为： 概念视图，有时候也称为 “逻辑视图”，这种视图显示了系统的主要部分以及它们之间的相互关系。 再例如，一种称为“4视图法”的架构设计方法在业界有一定影响，该方法也误把“概念架构”当成了“概念架构视图”。 其实，视图与视图之间必须是并列的关系，是一种并行思维关系。概念架构不可能与“模块 + 接口”一级的设计并列。概念架构不是一个“架构设计视图”。 正确的做法是，概念架构是一个“架构设计阶段”，必须在细化架构阶段之前，针对重大需求、特殊需求、高风险需求，形成稳定的高层架构设计成果。 阶段之于方法的意义和视图大不相同： 阶段是先后关系，视图是并列关系，这其中有本质区别。 不同阶段解决不同层次的问题--概念架构确定架构设计的大方针。 阶段应该与明确的里程碑想对应--概念架构确定的是高层分割方案及其他重要决策是否合理？ "},"ch7/7.4.html":{"url":"ch7/7.4.html","title":"7.4. 实践要领","keywords":"","body":"7.4. 实践要领 很多有经验的架构师已经意识到概念架构的重要性，却缺乏理性方法的指导。我们来讲讲ADMEMS方法Conceptual Arch阶段的核心理念和3个步骤。 7.4.1. 重大需求塑造概念架构 ADMEMS方法Conceptual Arch阶段的核心理念： 重大需求塑造概念架构，这里的“重大需求”应涵盖功能需求、质量及约束3来需求中的关键部分。 概念架构针对重大需求、特色需求、高风险需求，给出高层次解决方案 问题1： 过于理想化 问题2： 未来修改很大 如果只考虑“功能需求”来设计概念架构，将导致概念架构沦为“理想化架构”，这个脆弱的架构不久就会面临“大改”的压力，甚至直接导致投标等工作失败。 7.4.2. 概念架构阶段的3个步骤 概念架构设计分为3个步骤： 初步设计：基于关键功能，借助鲁棒图进行以发现职责为目的的初步设计。这一步并不总是需要，但对于架构师而言，是“新系统”就必须重视这一步。 高层分割：对系统这个黑盒子进行高层切分，例如切分复杂系统为多个二级系统，或者直接切分系统为具体子系统。 考虑非功能需求：概念架构 ≠ 理想化架构，所以不仅要考虑功能，也必须考虑非功能。 "},"ch8/":{"url":"ch8/","title":"第8章 初步设计","keywords":"","body":"第8章 初步设计 好的开始是成功的一半。 -- 谚语 所谓鲁棒性分析时这样一种方法： 通过分析用例规约中的事件流，识别出实现用例规定的功能所需要的主要对象及其职责，形成以职责模型为主的初步设计 -- 温昱，《软件架构设计》 Conceptual Architecture阶段包含3个步骤： 第1步，初步设计。 第2步，高层分割。 第3步，考虑非功能需求。 "},"ch8/8.1.html":{"url":"ch8/8.1.html","title":"8.1. 初步设计对复杂系统的意义","keywords":"","body":"8.1. 初步设计对复杂系统的意义 初步设计并不总是必须的 -- 架构师只有在设计复杂系统时才需要它。 另外，“复杂”与否还和“熟悉”程度有关系。一个“很小”的系统涉及你未接触的领域，你会觉得它复杂的；一个“较大”的系统，但你有很具体的经验，你依然会觉得它“Just so so”。 初步设计的目标简单而明确：那就是发现职责。初步设计无须展开架构设计细节，否则就背上了“包袱”，这是复杂系统架构设计起步时的大忌。正如“初步设计”这个名字所暗示的，它只是狭义的架构设计的“第一枪”--之前的Pre-Architecture阶段并未对“系统”做任何“切分”。 “初步设计”这个名字还暗示我们，后续的架构设计工作必须以之为基础。具体而言，初步设计识别出了职责，后续的高层分割方案才能有依据，因为每个“高层分割单元”都是职责的承载体，而分割的目的也恰恰在于规划高层职责模型。 ADMEMS方法强调“关键需求决定架构”的策略，“基于关键功能，进行初步设计”就是一个具体体现。 系统的每个功能都是由一条“职责协作链”来完成的；而初步设计的具体思路正是“通过为功能规划职责协作链来发现职责”。 "},"ch8/8.2.html":{"url":"ch8/8.2.html","title":"8.2. 鲁棒图简介","keywords":"","body":"8.2. 鲁棒图简介 ADMEMS推荐以鲁棒图来辅助初步设计。那么，什么是鲁棒图呢？ 8.2.1. 鲁棒图的3种元素 鲁棒图包含3中元素，它们分别是边界对象、控制对象、实体对象。 边界对象对模拟外部环境和内部系统之间的交互进行建模。边界对象负责接收外部输入，处理内部内容的解释，并表达或传递相应的结果。 控制对象对行为进行封装，描述用例中事件流的控制行为。 实体对象对信息进行描述，它往往来自领域概念和领域模型中的对象有良好的对应关系。 因为“类比思维”在人的头脑中是根深蒂固的，关于鲁棒图3元素的“类比”，自然是MVC。我们做了全面的对比，两者之间还是有不小的差异的。 鲁棒3元素和MVC的主要不同在于： View仅涵盖了“用户界面”元素的抽象，而鲁棒图的边界对象全面涵盖了三种交互，即本系统和外部“人”的交互、本系统与外部“系统”的交互、本系统与外部“设备”的交互。 数据访问逻辑Controller吗？不是。控制对象广泛涵盖了应用逻辑、业务逻辑、数据访问逻辑的抽象，而MVC的Controller主要对应于应用逻辑。 MVC的Model对应于经典的业务逻辑部分，而鲁棒图的实体对象更像“数据”的代名词--用实体对象建模的数据既可以是持久化的，也可以仅存在内存中，并不像有的实践者理解的那样直接就等同于持久化对象。 8.2.2. 鲁棒性一例 如银行存储系统的“销户”功能的鲁棒图。 为了实现销户的功能，银行工作人员要访问3个边界对象： 活期账号销户界面 磁卡读取设备 打印设备 “销户”是一个“控制对象”，和“计算利息”一起进行销户功能的逻辑控制。 其中，“计算利息”对“活期账户”、“利息率”、“利息税率”这3个“实体对象”进行读取操作。 而“销户”负责读出“客户资料”......最终销户的完成意味着写入“活期账号”和“销户流式”信息。 8.2.3. 历史 鲁棒图(Robustness Diagram)是由Ivar Jacobson于1991年发明的，用以回答“每个用例都需要哪些对象”的问题。 后来的UML并没有将鲁棒图列入到UML标准，而是作为UML版型（stereotype）进行支撑。 对于RUP、ICONIX等过程，鲁棒图都是重要的支撑技术。当然，这些过程反过来也促进了鲁棒图技术的传播。 8.2.4. 为什么叫“鲁棒”图 那为什么叫鲁棒图？它和鲁棒性有什么关系？ 答案是：词汇相同，含义不同。 软件系统的”鲁棒性（Robustness）“也是经常被翻译成”健壮性“，它同时和”容错性(Fault Tolerance)“含义相同。具体而言，鲁棒性指当下发生时依然具有正确运行功能的能力：非法输入数据、软硬件单元出现故障、未料到的操作情况。 鲁棒图的作用有两点： 初步设计 检查用例规约是否正确和完善 ”鲁棒图“正是因为第2点作用而得名的--所以，严格来讲”鲁棒图(Robustness Digagram)“所指的不是\"鲁棒性(Robustness)\"。 从Doug Rosenberg在《用例驱动的UML对象建模应用》的描述中，也可得到上述结论： 在ICONIX过程中，鲁棒分析扮演了多个必不可少的角色。通过鲁棒分析，您将改进用例文本和静态模型。 有助于区别用例文本的正确性，且没有指定不合理或不可能的系统行为（基于要使用的一组对象），从而提供了健康性检查（Sanity Check）。这种改进使用用例文本的特性从纯粹的用户手册角度变成对象模型上下文中的使用描述。 有助于区别用例考虑到所有必须的分支流程，从而提供了完整的正确性检查。经验表明，为实现这种目标，并编写出遵循某些定义良好的指南的问题，而在绘制鲁棒图上花费的时间，将在绘制时序图时3-4倍的节省下来。 有利于发现对象，这一点很重要，因为在建模期间肯定会遗漏一些对象。你还可以发现对象命名冲突的情况，从而避免进一步造成严重的问题。另外，鲁棒分析有利于确保我们在绘制时序图之前确定大部分实体类和边界类。 8.2.5. 定位 不要再困惑于类似”鲁棒图是分析技术，还是设计技术“这样的问题了。大家只需要记住两个公式： 需求分析 ≠ 系统分析 系统分析 ≈ 初步分析 关于”分析“和”设计“的区分，在《面向对象的系统设计》一书中早已做过精彩的阐述： 在”做什么“和”怎么做“来区分分析与设计，是从结构化方法沿袭过来的一种观点，但即使在结构化方法沿袭过来的一种观点，但即使在结构化方法中这种说法也很勉强...... 在”做什么“和”怎么做“为什么会出现上述矛盾？究其根源，在于人们对软件工程中”分析“这个术语的含义有着不同的理解--有时把它作为需求分析（Requirements Analysis）的简称，有时又指系统分析（Systems Analysis），有时则作为需求分析和系统分析的总称。 需求分析时软件工程学中的经典术语之一，名副其实的含义应是对用户需求进行分析，旨在产生一份明确、规范的需求定义。从这个意义上讲，”分析是解决做什么而不是解决怎么做“是无可挑剔的。 但迄今为止，在人们提出的各种分析方法（包括结构化分析和面向对象分析）中，真正属于需求分析的内容所占的分量并不大；更多的内容是给出一种系统建模方法（包括一种表示法和相应的建模过程指导），告诉分析员如何建立一个能够满足（由需求定义所描述的）用户需求的系统模型。分析员大量的工作是对系统的应用领域模型进行调查研究，并抽象表示这个系统。确切的讲，这些工作应该叫做系统分析，而不是需求分析。它既是对“做什么”问题的进一步明确，也在相当程度上设计“怎么做”的问题。 忽略分析、需求分析和系统分析这些术语的不同含义，并在讨论中将它们随意替换，是造成上述矛盾的根源。 至于实践者为什么常将“需求分析”和“系统分析”混淆，这背后有着重要的现实原因。实际的工程化实践中，需求捕获、需求分析、系统分析并不是完全孤立进行的。想法，它们往往是相互伴随、交叉进行的。需求工作伊始，无疑更多是进行需求捕获工作，相伴进行的需求分析工作所占的比例偏少；但随着掌握的需求信息越来越多，我们需要开展对需求的分析和整理工作也越来越多了；而此时，伴随着对问题的分析，自然而然会在高层次提出相应的应对策略......这恰恰就是系统分析工作。 《软件架构设计》一书中有如下阐述： 需求捕获是获取知识的过程，知识从无到有，葱烧到多。需求采集者必须立即用户所充实的工作，并了解用户客户希望软件系统在哪个方面能够帮助他们。 需求分析是挖掘和整理知识的过程，它在已掌握知识的基础上进行。毕竟，初步捕获到的需求信息往往处于不同的层次，也有一些主观深圳不正确的信息。而经过必要的需求分析工作之后，需求更加系统、更加有条理、更加全面。 那么系统分析呢？如果说，需求分析致力于搞清楚软件系统要“做什么”的话，那么系统分析已经开始涉及“怎么做”的问题了。 《系统分析与设计方法》一书中写道： 简单的说，系统分析的意义如下：“系统分析是针对系统所要面临的问题，搜集相关的资料，以了解产生问题的原因所在，进而提出解决问题的方法和可行的逻辑方案，以满足系统的需求，实现预定的目标。” 需求捕获、需求分析，以及系统分析之间的关系，我们必须理解透彻，否则会影响工作的有效进行。 再次强调，鲁棒图已经“打开”了“系统”这个“黑盒子”，将它划分成很多的不同的职责，所以它是“设计技术”。 "},"ch8/8.3.html":{"url":"ch8/8.3.html","title":"8.3. 基于鲁棒图进行初步设计的10条经验","keywords":"","body":"8.3. 基于鲁棒图进行初步设计的10条经验 ADMEMS方法归纳了鲁棒图建模的10条经验要点，分别覆盖了语法、思维、技巧、注意事项等4个方面。 语法 遵循建模规则 简化建模语言 思维 遵循3种元素的发现思路 增量建模 实体对象 ≠ 持久化对象 技巧 只对关键功能（用例）画鲁棒图 每个鲁棒图有2~5个控制对象 注意 勿关注细节 勿过分关注UI，除非辅助或验证UI设计 鲁棒图 ≠ 用例规约的可视化 8.3.1. 遵循建模规则 Doug Rosenberg在《UML用例驱动对象建模》中写道： 通过以下4条语言，可以理解该图的本质： 参与者只能与边界对象交谈。 边界对象只能与控制对象和参与者交谈。 实体对象也只能与控制对象交谈。 控制对象既能与边界对象交谈，也能与控制对象交谈，但不能与参与者交谈。 8.3.2. 简化建模语法 在实践中，简化的鲁棒图语法将有利于你集中精力进行初步设计，而不是关注细节。 例如，鲁棒图根本不关心“IF语言”怎么建模。 值得注意的是，业界有些观点（包括一些书）认为鲁棒图是协作图。因此造成了鲁棒图的语法非常复杂，不利于专注于初步设计。 其实，鲁棒图是一种非常特殊的类图。 8.3.3. 遵循3种元素的发现思路 用例（Use Case） = N个场景（Scenario）。每个场景的实现都是一连串的职责进行协作的结果。所以，初步设计可以通过“研究用例执行的不同场景，发现场景背后应该有哪些不同的职责”来完成。 8.3.4. 增量建模 “建模难”，有些人常如此感叹。例如，在画鲁棒图时，许多人以上来就卡在了“搞不清应该有几个界面”的问题上，就会发出“建模难”的感叹。 下面演示“增量建模”这种技巧。从小处讲，增量建模能解决鲁棒图建模卡壳的问题；从大处将，这种方式适合所有种类的UML图建模实践。 例如，类似WinZip、WinRar这样的压缩工具大家都用过。请一起来为其中的“压缩”功能进行基于鲁棒图的初步设计。 首先，识别最明显的职责。对就是你自己认为最显著的几个职责--不要任务设计和建模有严格的标准答案。 源文件 压缩包 压缩器（负责压缩处理） 接下来，开始考虑职责间的关系，并发现新职责。压缩器读取源文件，最终生成压缩包。 这里将打包器独立出来，它是受了压缩器的委托而工作的。还有字典...... 继续同样的思维方式，又引入了压缩配置，它影响着压缩器的工作方式，例如加密压缩、分卷压缩或其他。 压缩功能还要显示压缩进度，以及随时取消进行一半的压缩工作。所以，你又识别出了压缩进行界面和监听器等职责。 模型之于人，就像马匹之于人一样--它是工具。如果你不知道怎样真正将“模型”为自己所用，反而为“建模”所累（经典的“人骑马、马骑人”的问题），请问自己一个问题： 我是不是被太多的假设限制了思维？，或许，工具本身根本没有这样的限制我！ 8.3.5. 实体对象 ≠ 持久化对象 实体对象涵盖的更广泛，它可以是持久化对象，也可以是内存中的任何对象。 一方面，在实践中，有些系统需要在内存中创建数据的“暂存体”以保持中间状态，当然可以被建模成实体对象。另一方面，有的系统没有持久化数据，但是基于鲁棒图的设计依然可以用，此时难道鲁棒图不包含实体对象吗？显然不对。 因此，实体对象 ≠ 持久化对象，这个正确认识将有助于你的实践。 8.3.6. 只对关键功能（用例）画鲁棒图 基于“关键需求决定架构”的历练，功能需求作为需求的一种类型，在架构设计时不必针对每个功能都画出鲁棒图。 8.3.7. 每个鲁棒图有2~5个控制对象 既然是初步设计，鲁棒图建模时，针对关键功能的每个鲁棒图中的控制对象不必太多太细，5个是常见的上限值。 相反，若实现某个功能的鲁棒图只包含一个控制对象，则是明显的“设计不足”--这个控制对象的名字必然和功能的名词相同，这意味着没有对职责进行真正的切分。 例如，WinZip的压缩功能设计成下面的鲁棒图，几乎没有任何意义。 8.3.8. 勿关注细节 初步设计不应该关注细节。例如，回顾前面所示的“销户”的鲁棒图： 对每个对象只标识对象名，都未识别其属性和方法。 “活期账户销户界面”，具体可能是对话框、Web页面、字符终端界面，但鲁棒图中没有关心这些细节问题。 “客户资料”等实体对象必须要持久化吗？不关心，更不关心用Table还是File或其他方式持久化。 没有标识控制流的严格顺序。 8.3.9. 勿过分关注UI，除非辅助或验证UI设计 过分关系UI，会陷入诸如有几个窗口，是不是有一个专门的结果显示页面等诸多细节之中，初步设计就没法做了。 别忘了，初步设计的目标是发现职责。初步设计无需展开架构设计细节，否则就背上了“包袱”，这是复杂系统设计起步时的大忌。 8.3.10. 鲁棒图 ≠ 用例规约的可视化 鲁棒图时设计，“系统”已经别切分成不同的职责单元。而用例规约是需求，其中出现的“系统”必定是黑河。所以，两者有本质区别。 "},"ch8/8.4.html":{"url":"ch8/8.4.html","title":"8.4. 贯穿案例","keywords":"","body":"8.4. 贯穿案例 接下来考虑贯穿案例PASS系统，如何借助鲁棒图进行初步设计呢？ 再次明确一下几点： 初步设计的目标是发现职责，为高层切分奠定基础 初步设计不是必须，但待设计的系统对架构师而言并无太多直接经验时，强烈建议进行初步设计 基于关键功能（而不是所有功能），借助鲁棒图（而不是时序图）进行初步设计 下面，我们一起思考如何针对“实时检查处方”功能进行初步设计--重点体会“增量建模”的自然和强大。 首先，识别最明显的职责。先识别出最不可或缺的、体现整个功能价值所在的、与“处方检查结果”相关的几个职责。 接下来开始考虑职责间的关系，并发现新职责。检查结果是如何产生的呢？检查这个控制对象，读取处方和用户规则信息，最终生成处方检查结果。 OK，如此一来，解决了“结果是怎么来的这个问题”。 继续以同样的思维方式解决问题。PASS系统自动检查处方，是由HIS系统中意识工作站的调用触发的，处方信息也是通过某种方式（例如参数或XML文件）从HIS医生工作站获得的。 实时检查处方最终的鲁棒图又进一步考虑了“记录违规用药”这一具体功能场景的支持。 概念架构设计时推荐只对关键功能进行鲁棒图建模。例如，另一关键功能“自动更新用药规则”的鲁棒图设计如下： "},"ch9/":{"url":"ch9/","title":"第9章 高层分割","keywords":"","body":"第9章 高层分割 复杂性是层次化的。 -- Frederick.P.Brooks,《人月神话》 分析与综合是思维方向相反的过程。一部是先分析后综合，没有分析就不能综合；没有综合的分析，也只有片面的分析。 -- 肖纪美，《梳理人、事、物的纠纷：问题分析方法》 “架构 = 模块 + 接口”的做法，其不足可概括为两点。 第一，忽视了多视图。“模块 + 接口”仅是逻辑架构设计视图的核心内容，而软件系统的架构设计还可能涉及开发视图、运行视图、物理视图、数据视图等多方面的考虑。 第二，忽略了概念架构设计。对规模较大的系统而言，都必须先根据重大风险（包含功能方面、质量方面、约束方面），有针对性的制定包括“高层分割”在内的设计决策，然后才是“模块 + 接口”一级的设计。 那么，如何对软件系统进行“高层分割”呢？这属于Conceptual Architecture阶段第2步的工作。也真是这一章要说的主题。 "},"ch9/9.1.html":{"url":"ch9/9.1.html","title":"9.1. 高层分割的两种实践套路","keywords":"","body":"9.1. 高层分割的两种实践套路 切系统为系统 切系统为子系统 在实践中，经常出现这两种方式。虽然从理论上，设计是层层嵌套展开的--即“每一级的子系统”对“下一级的子系统”而言都是系统，都可以单独定义需求和进行设计。但这里更强调“两种套路”的思维。 也就是说： 要么告诉自己：我面对的是1个“系统的系统(System of Systems)” 要么告诉自己：我要把这个“原子系统”切成若干子系统 9.1.1. 切系统为系统 “切系统为系统”是一种缩略的说法，具体是指： 系统比较复杂，需要进行两级高层切分。 首先，把系统切成更小一级的系统，每个更小一级都可以有单独的需求、设计、实现...... 之后，针对每个“更小一级的系统”进行“切系统为子系统”...... 这样做的现实意义是巨大的。 面临比较复杂的软件系统，很多企业都有“这个项目要设几个架构师”的困惑。以电信或广电领域的BOSS系统为背景。 在实践中，当面临如下两种情况时，你需要考虑“切系统为系统”： 当系统覆盖的功能范围比较广泛 例如，BOSS系统设计的需求范围广泛--涵盖网络管理、服务开通、计费、客户关系管理等，于是按照“切系统为系统”的做法分为网管系统、服务受理系统、计费系统、客户关系管理系统等。 当系统需要部署在比较复杂的硬件环境中 很多城市基础服务行业、大型机构、大型企业，都很重视“一卡通”的应用。例如，如一卡通系统要无缝支持HR管理、出入控制、后勤保障等方面的功能，就必须充分考虑复杂的硬件环境给架构带来的冲击--硬件的种类设计考勤机、通道机、闸机、自助查询机、PC机、服务器等，于是应当合理规划组成整个一卡通系统的嵌入式应用、桌面应用及Web应用等。 9.1.2. 案例：SAAS模式的软件租用平台架构设计 再举一例，来说明如何进行“切系统为系统”式的高层分割。 案例背景 SAAS风潮又起（以前叫ASP），“软件租用平台”为用户提供统一的软件租用服务。如上下文图 软件租用平台提供的高层功能描述，如业务用例图。 高层分割的思维 业界有数据表明，需求的复杂程度没增加25%，解决方案的复杂程度就增加100%。那么，我如果应该把“软件租用平台”切成三四个相对独立的系统而没切，就意味着人为的制造灾难--太多问题相互杂糅在一起，造成解决方案的复杂程度陡增。 借助鲁棒图，初步识别功能背后的职责，就可以规划高层切分的具体方式。 具体思维过程如下： 结果呢？1个系统被切为3个系统--组件管理系统、运营管理系统、应用定制系统。 分别设计和开发这3个单独的系统，比直接把软件租用平台当成1个System开发的可控性高多了。复杂性是根本问题（《人月神话》语），虽然无法降低，但是可以控制。 9.1.3. 切系统为子系统 这种方式相当经典，无需太多铺垫。实践中，最常见的就是分层。 案例背景 使用用例图来描述PM系统的功能 高层分割 PM系统的高层分割，采用了经典的4层架构方式。 "},"ch9/9.2.html":{"url":"ch9/9.2.html","title":"9.2. 分层式概念服务架构","keywords":"","body":"9.2. 分层式概念服务架构 人们常说，“分层式最流行的架构模式”。从字面上理解，这似乎意味着大家所进行的“分层”在思想层面上是一致的。但事实并非如此。在实践中，分层有不同的角度，并且互不矛盾。通常会总结为“3 + 1”流派。 Layer：逻辑层 Tier：物理层 按通用性分层 技术堆叠 9.2.1. Layer:逻辑层 逻辑层(Layer)重视职责的划分，职责之间常常是上层使用下层的关系--但是根本不关心上层和下层是否“能分布”在不同机器上。 图片来源：Layered Business Architectures: Logical Structures 图中的Services层对下层Domain Model部分的访问，是一种跨机器的远程访问吗？ 答案是：不知道，也不关心。整个架构图中的箭头表示的是逻辑上服务使用关系，而对物理角度是否是跨机器的访问方式并不关心。 按Layer分层 ≠ 按Tier分层。 图中的User Interface、Services、Domain Model和Persistent Data是通用性逐渐增加吗？（”通用性越大，所处层次就越靠下“是按通用性分层的常见方式。） 答案是：无法确定那一层更通用。例如，作为最下层的Persistent Data层本来支持硬盘，但后来要支持磁盘阵列，再后来要支持SAN（存储区域网络），这都要求存Persistent Data层要有针对性的进行改变。 按Layer分层 ≠ 按通用性分层。 9.2.2. Tier: 物理层 物理层(Tier)指”能分布“在不同机器上的软件单元，不同的物理层之间必须有跨机器访问的能力--可以通过远程调用、或通讯协议等方式。 图片来源：Oracle Application Server Containers for J2EE 关于Tier这种分层方式， 最需要强调的是，几层(Tier)架构是看”能分布“的能力，不是看”实际部署情况“。 我们常说的Java EE应该是N-Layer的，因为从逻辑上来看，Java EE里面有表现层、业务逻辑层和数据持久层。从物理上而言，这3层可以在不同的Tier上（表现层在PC上，业务逻辑层在应用服务器上，数据持久层在数据库服务器上），也可以在一个Tier上，比如Martin说过，如果把数据库、应用服务器和浏览器都装在一台电脑上，那么3-layer就在1-tier上了。 这段话问题不小。 毕竟，”N-Tiers架构“的一大好处是可伸缩性--业务量小的时候将N个Tier都部署在同一台机器上 ，等业务量大的时候再为每个Tier单独安排一台或一组机器，这恰恰是\"N-Tiers架构\"的目标！所以，一个系统如果架构设计时是”4-Tiers架构“的，并且开发时也实现了这一点，那么把它们部署在同一台机器上并没有改变”4-Tiers架构“。最终，工程师的实际部署方案觉得了系统是几层(Tier)架构，这未免荒唐。 其实，总结出”3级“映射关系（而不是”两级“）就清楚了： 逻辑层Layer -> 物理层Tier -> 一台或一组计算机 关于按Tier分层 ，再看一例：微软的Azure虚拟网络系统，很明确的进行了不同的tier的划分，各层之间必然是能以进行跨机器方式的协议互相通讯的（只不过每个Tier的部署规模比较大罢了）。 图片来源：Azure中具有Apache Cassandra的Linux多層式架構 (N-tier) 應用程式 9.2.3. 按通用性分层 严格来讲，按通用性分层是另一种Layer，但是，绝对有必要让它”独立门户“以引起实践者的足够重视。 按通用性分层式只：将通用性不同的部分划归不同的层，以此作为系统的总体切分方式。 一般而言，通用程度越大，所处层次就越靠下。 不同，嵌入式系统的分层架构有所不同：通用性最强的层位于中间，硬件相关的部分，以及应用特点部分分布位于下层和上层。 这种“中间通用、上下专用”的分层方式对可移植性关键的通信系统、控制系统、软件平台等情况都非常重要。 9.2.4. 技术堆叠 技术堆叠不是独立的架构，而是基于分层架构（或其他架构模式）提供的进一步说明。 下面这个两个架构模式都是按Tier分层，并明确了各个技术点。 图片来源：I Love the Java Jive: J2EE for Oracle Technologists 图片来源：Category Archives: Day 15. Understanding J2EE Architecture 另一个例子，基本架构模式是基于通用性分层的，也加入技术堆叠的描述。 图片来源：Java SpringMVC "},"ch9/9.3.html":{"url":"ch9/9.3.html","title":"9.3. 给架构师的提醒","keywords":"","body":"9.3. 给架构师的提醒 许多架构师认为，架构就是把系统切成框框，再在框框之间连上线。这种观点太片面了。 高层分割很重要，但不是概念架构的全部。除了切分策略之外，概念架构还包括技术选择、权衡策略等种类的决策。 例如，为了支持各种相互矛盾的非功能需求，仅调整切分方式还远远不够的。 "},"ch9/9.4.html":{"url":"ch9/9.4.html","title":"9.4. 贯穿案例","keywords":"","body":"9.4. 贯穿案例 继续PASS系统的贯穿案例。 由于PASS系统的分布式特点明显，所以高层分割除了考虑常见的Layer方式之外，我们也考虑Tier。而通过主动考虑“按通用性分层”，我们也大有收获--确定引入“PASS医生模块通用SDK”而使无谓的重复开发工作量降至最低。 9.4.1. 从初步设计到高层分割的过渡 我们在之前完成了初步设计成果，通过对这些已发现的职责进行“综合”，可以确定系统基本的高层分割方式。 9.4.2. PASS系统Layer设计 于是，可以得到按Layer对PASS系统进行高层分割的方式。 9.4.3. PASS系统之Tier设计 按Layer切分为反应PASS系统很强的分布式特点，我们应进一步从Tier角度考虑PASS系统的高层分割方式。 9.4.4. 引入通用性分层 如果进一步质疑“可重用性”(详见第10章的“贯穿案例”部分的目标-场景-决策表)，应将嵌入HIS的程序进一步切分--分出“PASS系统医生模块通用SDK”，它和任何具体HIS无关，所以通用性高，应分离出去。 "},"ch10/":{"url":"ch10/","title":"第10章 考虑非功能需求","keywords":"","body":"第10章 考虑非功能需求 架构不仅仅是系统功能需求的结果 -- Len Bass, 《软件架构实践(第二版)》 在我们当中，有不少人一厢情愿的认为：只要所开发出的系统完成了用户期待的功能，项目就算成功了，但这并不符合实际。 -- 温昱,《软件架构设计》 《软件架构设计》一书中指出，“其实任何作为复合整体的复杂事物都有可能有架构，比如一本书”。“非功能目标的考虑”在ADMEMS方法中不是一个阶段，而是一个贯穿环节。 我们接下来讨论的重点是贯穿案例 -- PASS系统概念架构设计的第3步，考虑非功能需求。 "},"ch10/10.1.html":{"url":"ch10/10.1.html","title":"10.1. 考虑非功能目标要趁早","keywords":"","body":"10.1. 考虑非功能目标要趁早 概念架构 ≠ 理想化架构 重大需求塑造概念架构。这里的 “重大需求”应涵盖功能需求、质量及约束3类需求中的关键部分。 概念架构是一个“架构设计阶段”，必须在细化架构设计阶段之前，针对重大需求、特色需求、高风险需求，形成稳定的高层架构设计成果。 如果只考虑“功能需求”来设计概念架构，将导致概念架构沦为“理想化架构”，这个脆弱的架构不久就会面临“大改”的压力，甚至直接导致投标等工作失败。 "},"ch10/10.2.html":{"url":"ch10/10.2.html","title":"10.2. 贯穿案例","keywords":"","body":"10.2. 贯穿案例 非功能需求往往非常笼统，而场景是一种明确性很强的技术。目标-场景-决策表可以让架构师理性应对非功能需求。 通过场景，我们质疑ile可重用性的做法。为了避免开发多个孤立的“医生工作站嵌入单元”，引入的设计决策是 “分离出不变部分”，将“PASS系统医生模块通用SDK”提炼出来（见9.4.4. 引入通用性分层） 不要忘记了架构设计是质疑驱动的--概念加过也经常经过多次循环的设计结果(如7.4. 实践要领提到概念架构实践要领)。现在我们来质疑PASS系统的持续可用性，它毕竟是用于辅助医院运营的系统。 根据上述基于目标-场景-决策表的思考，我们调整系统的原有架构图，经验告诉我们，考虑非功能需求会引起“架构中间设计成功”的调整！ "},"ch11/":{"url":"ch11/","title":"第11章. 细化架构的故事","keywords":"","body":"第11章. 细化架构的故事 如果一个项目的系统架构（包括理论基础）尚未定义，就不应该进行此系统的全面开发。 -- Barry Boehm, 《Software Engineering》 如果选择视图的工作没做好，或者以牺牲气体视图为代价，只注重一个视图，就会掩盖问题以及延误解决问题。 -- Grady Booch, 《UML用户指南》 从概念架构到细化架构，先设计概念架构，构思关键问题的解决策略；再进行细化架构的设计，以保证为开发提供足够的指导和限制...这符合人类解决问题的规律，因此被广泛采用。 但在实际中，细化架构设计还存在很多差强人意之处，甚至经常被忽视。 "},"ch11/11.1.html":{"url":"ch11/11.1.html","title":"11.1. 骄傲的架构师，郁闷的程序员","keywords":"","body":"11.1. 骄傲的架构师，郁闷的程序员 11.1.1. 故事：《方案书》确定之后 公司在谈一个项目，但还没有得到客户的认可。后来，除了老李这个项目经理之外，小张作为架构师、小王作为需求分析师也都参与了进来。他们几个在和客户沟通的基础上，通力合作，最后成功提交了《方案书》，并获得客户的认可。《方案书》是老李、小张、小王各负责一部分来写的，其中架构师小张负责总体设计部分。 小张认为：《方案书》被认可说明架构已经很明确，无须“再”架构设计了。 最后，苦了程序员，因为他们在实际开发过程中没有得到足够的指导和限制。 11.1.2. 探究：“方案”与“架构”的关系 究其原因，这是因为概念架构难以支持并行开发。要支持开发组相对独立进行工作，需要提供指导和限制作用更明确的“规约”一级的设计。 具体而言，细化架构和概念架构之间存在如下典型差异： 接口：在细化架构中接口占据非常核心的地位，而概念架构并不明确接口定义（只有抽象的组件和抽象的交互机制）。 子系统：细化架构重视通过子系统和模块来分割整个系统，并且子系统往往有明确的接口；而概念架构中只有抽象的组件，这些组件没有接口，只有职责，一般是处理组件、数据组件胡哦哦连接组件中的一种。当然，概念架构中也有“大组件分解成小组件”的设计决策，但并非子系统的含义。 交互机制：细化架构中的交互机制应是“实在”的，如基于接口编程、消息机制或远程方法调用等；而概念架构中的交互机制是“概念化”的。例如“A层使用B层的服务”就是典型的例子，这里的“使用”到了细化架构中可能基于接口编程、消息机制或远程方法调用等其中的一种。 当然，概念架构和细化架构都满足软件架构的定义--无论是“架构 = 组件 + 交互”，还是“架构 = 重要决策”。 方案的设定，为什么需要项目负责人、需求人员、架构师等功能参与呢？因为方案涉及的工作内容不仅仅是架构，还涉及项目管理和需求工作。“方案”和“架构”的联系与区别如下： 方案包含一定的架构内容 方案涉及的架构基本在概念架构一级 架构设计的工作还远未完成 所以，架构师应记住： 方案 = “项目 + 需求 + 架构”的总览 方案 ≠ 架构的全部 "},"ch11/11.2.html":{"url":"ch11/11.2.html","title":"11.2. 办公室里的争论","keywords":"","body":"11.2. 办公室里的争论 11.2.1. 故事：办公室里，争论正酣 办公室里，关于什么是软件架构，争论正酣。 程序员说，软件架构就要决定要编写哪些类，使用哪些现成框架(Framework)。 程序经理说，软件架构就是模块的划分和接口的定义。 系统分析员说，软件架构就是为业务领域对象的关键建模。 配置管理员说，软件架构就是开发出来的及编译后的软件到底是啥结构。 数据库工程师说，软件架构规定了持久化数据的结构，其他一切不过是对数据的操作而已。 部署工程师说，软件架构规定了软件部署到硬件的策略。 用户说，软件架构就是决定一个个功能子系统如何划分。 大家想了想说，这些架构视图好像我们都需要啊，软件架构师哭了。 11.2.2. 探究：优秀的多视图方法，应贴近实践 上述争论可以总结为一句话：不同涉众看待软件架构的视角是不同的。 但是，实际工作中架构师的工作范围如此广泛，多视图方法能系统的涵盖吗？例如： 进程、线程的相关设计 接口的定义 子系统的划分 服务器的选型 （若你用C）结构化方法的模块设计“放”哪里？ 考虑Layer（逻辑层） 考虑Tier（物理层） （基于并行开发的需要）源程序目录结构的定义 数据分布与数据库Schema (若没选RDBMS而选了文件方式)文件格式的定义 （嵌入式系统常将数据保存到Flash）Flash存储结构的定义 ...... 答案是：贴近实践的多视图方法，应将各项工作涵盖其中。 运行架构 进程、线程的相关设计 逻辑架构 接口的定义 子系统的划分 （若你用C）结构化方法的模块设计“放”哪里？ 考虑Layer（逻辑层） 物理架构 服务器的选型 考虑Tier（物理层） 开发架构 （基于并行开发的需要）源程序目录结构的定义 数据架构 数据分布与数据库Schema (若没选RDBMS而选了文件方式)文件格式的定义 （嵌入式系统常将数据保存到Flash）Flash存储结构的定义 "},"ch11/11.3.html":{"url":"ch11/11.3.html","title":"11.3. 展望细化架构阶段","keywords":"","body":"11.3. 展望细化架构阶段 总结一下。首先，架构设计仅进行到概念架构层面，对团队的并行开发而言是远远不够的；常见的错误就是把《方案书》中的概念架构设计部分直接作为《架构设计文档》提交。另外，业界早已存在一些有影响力的多视图方法（例如RUP4+1视图方法），但是作为一线架构师，要有意识的调整、扩充、改进经典方法以符合实践的真正需要。 "},"ch12/":{"url":"ch12/","title":"第12章. 细化架构总论","keywords":"","body":"第12章. 细化架构总论 假设有一座漂亮的大房子，一个人站在房子的前面，一个人站在房子的后面，另外两个人分别站在房子的左右两侧。四个人看房子都有不同的视角，四个人都在争论自己看到的那一面是正确的一面，如果运用水平思考，那么这四个人就会绕房子一圈，分别看到房子前后左右四个面。 -- 爱德华.德.博诺，《六顶思考帽》 总的来说，“架构”一词涵盖了软件架构的所有方面，这些方面紧紧的缠绕在一起，决定如何将之分割成部分和主题显得相当主观。既然如此，就必须引入“架构视点”作为讨论、归纳和理解大型系统架构的手段 -- Peter Herzum, 《Business Component Factory》 架构设计是一门解决复杂问题的实践艺术。于是，以分而治之为思想核心的多视图方法必不可少。 接下来主要介绍支持细化架构设计的整体思路--多视图方法。 "},"ch12/12.1.html":{"url":"ch12/12.1.html","title":"12.1. 什么是细化架构","keywords":"","body":"12.1. 什么是细化架构 细化架构是相对于概念架构而言的，它们是架构设计的两个层次，分别对应于“概念级”解决方案和“规约级”解决方案。需要注意的是，系统架构属于架构设计，不能和Detailed Design(详细设计)相混淆。 架构领域最喜欢将建筑设计的多视图方法与软件架构设计的多视图方法做类比，在此就不在进行赘述，而是举一个更贴近生活的例子：装修的多视图方法 功能视图 布线视图 通过运用装修的两视图法，你的装修设计摆脱在一个图里画来画去（想来想去）的困境。其中，装修设计的功能视图比较多的考虑： 家具 家电 灯 窗帘 而布线视图则集中考虑： 插座 网线 电话线 有线电视线 我们还发现，功能视图和布线视图是相互影响的，例如插座不能设计在大衣柜的后面，否则无法使用。这与软件架构设计的多视图方法中“兼顾多个视图设计之间的一致性”的要求是神似的，例如架构设计要考虑职责、程序单元、部署节点等要素之间的相互影响。 "},"ch12/12.2.html":{"url":"ch12/12.2.html","title":"12.2. 实际意义","keywords":"","body":"12.2. 实际意义 关于多视图方法的价值，Len Bass等专家在《软件架构实践（第2版）》一书中论述道： 神经科专科医生、整形医生、血液专家和皮肤科医生对人体结构有着不同的视图。眼科医生、心脏病专家和足病医生研究治疗的是身体的某个部分。运动学专家和精神病专家关注的是整个人体行为的不同方面。尽管这些视图是不同的并且具有差异巨大的属性，但它们都具有内在相关性：它们共同描述了人体的结构。 软件也是如此。现代系统非常复杂，很难一下领会。相反，在任何时刻，我们只能把注意力放在软件系统的一个或几个结构上。为了有意义的传达架构的信息，必须说明此刻正在讨论哪个或哪些结构--即采用的是架构的哪个视图。 所以，多视图方法有两个方面的实际意义： 利于思考（因为分而治之的思维方式） 便于交流（因为在一定程度上分类了涉众关注点） "},"ch12/12.3.html":{"url":"ch12/12.3.html","title":"12.3. 业界现状","keywords":"","body":"12.3. 业界现状 12.3.1. 误认为多视图是OO方法分支 提问：Framework技术是OO的分支吗？不是，Framework本质上和面向对象无关，用C语言也可以编写Framework。更切切近本质的Framework的定义是：可以通过某种回调机制进行扩展的软件系统或子系统的半成品。 的确，OO方法太流行了，以至于很多技术都“变成”了OO的分支。 有同行也常常将多视图方法误认为是OO方法的分支。其实，无论是OO方法，还是结构化方法，都远未涵盖架构设计的全部。所以，只具有OO技能对架构师而言是不够的。 12.3.2. 误将“视图”当成“阶段” 对架构设计方法而言，区分阶段和视图的概念是非常重要和必要的。 “左边”的观点--概念架构、逻辑架构、物理架构是3个不同的层次。其实这种观点不完全正确，因为逻辑架构和物理架构是架构设计同一阶段中须要同时考虑的两个方面--即二者是两个视图，而非两个阶段。 12.3.3. RUP 4+1视图 在软件架构发展史上，4+1视图方法具有重大贡献。 1995年，Philippe Kruchten发表了题为《The4+1 View Model of Architecture》的论文，标志着4+1视图方法的诞生。后来，Philippe Kruchten加入Rational公司，4+1视图演化为下图所示的模样。 RUP4+1视图方法有几个重要特点： 重视OO方法 Use Case驱动 强调模型的重要性 对应于上述3个特点，架构师在实践中应注意： OO可以指导逻辑架构视图的设计，但是OO方法对物理视图等的设计指导很弱。另一方面，即使逻辑架构的设计，也未必都是以OO方法为指导的。例如，大量嵌入式软件系统和系统软件仍以C语言为主要开发语言，其逻辑架构设计还会以结构化方法为指导。 用例不是架构设计本身工作。4+1视图中的“4”是架构设计，“+1”是驱动因素。 建模切忌穷兵黩武。如果一个模型建立中没有启发思维，首次建立后从不修改，那么就要慎重考虑是不是“过度建模”了。 12.3.4. SEI 3视图 SEI的Len Bass等专家在《软件架构实践（第2版）》中阐述了“3视图”的观点，他们认为架构设计的工作应该包含3类视图： 模块视图：此处的元素是模块，它们是实现单元。模块表示一种考虑系统的基于代码的方法。模块被分配功能职责区域。这不怎么强调所开发出来的软件如何在运行时表现自己。模块结构能够回答诸如此类的问题：分配给每个模块的主要功能职责是什么？允许模块使用的其他元素是什么？它实际使用的其他软件是什么？什么模块通弄个泛化或特化（继承）关系与其他模块相关？ 组件-连接器视图：此处的元素为运行时组件（它们是计算的主要单元）和连接器（它们是组件间通信的工具）。组件-连接器结构回答了诸如此类的问题：we和你们是主要执行组件？它们如何交互？什么是主要的共享数据存储？复制系统的那些不法？数据在系统中经过了哪些地方？系统的哪些部分可以并行运行？在系统执行时，其结构可能会发生怎样的变化？ 分配视图：分配结构展示了软件元素和创建并执行软件的一个或多个外部环境中的元素之间的关系。它们回答了诸如此类的问题：每个软件元素在什么处理器上执行？在开发、测试和系统构建期间，每个元素都存储在什么文件中？分配给开发小组的软件元素是什么？ 来源：《Software Architecture in Practice》 总的来说，SEI 3视图方法没有RUP 4+1视图方法影响大，但也值得架构师研究和体会的。 例如： 映射视图对实践很有启发。以源码为核心的开发单元要分配给开发人员；而目标单元要和吴磊节点有映射关系，通过安装、部署、烧写等时候藕断完成。 “架构 = 组件 + 交互”是业界的基本认识，应该在架构的每个视图都有自己关心的“组件”。 "},"ch12/12.4.html":{"url":"ch12/12.4.html","title":"12.4. 实践要领","keywords":"","body":"12.4. 实践要领 一种优秀的多视图方法，应该能够比较完善的覆盖架构设计的各项哦工作内容，且将每项工作内容明确的、有理有据的、一目了然的规划到不同架构视图中去。 我们来介绍一下5视图方法的怨气，并用两幅画来说明5视图方法的主要思想：落错有致的将众多技术关键点划分成“群落”，“群落”高内聚，“群落”之间松耦合。所以，应用5视图方法，有利于架构师设计思维的“有序”展开。 12.4.1. 缘起：5视图方法的提出 多视图方法是业界广泛认同的一种架构设计思路，具体的多视图方法繁多： SEI的3视图方法。涉及视图为：模块视图、组件-连接器视图、分配视图。 西门子的4视图方法。涉及视图为：概念视图、模块视图、代码视图、执行视图。 RUP的4+1视图法。涉及视图为：用例视图、逻辑视图、开发视图、进程视图、物理视图。 联邦企业架构框架（Federal Enterpriese Architecture Framework）。涉及视图为：技术架构视图、信息架构视图、应用架构视图、业务架构视图。 其他...... 其中，无疑是由Philippe Kruchten于1995年首次提出的4+1视图方法的影响最大。 12.4.2. 总图：每个视图，一个思维角度 《第一财经》栏目有句广告语“有角度就有空间”，想想都觉得颇有道理--作为电视节目，选准了评论的“角度”，也就有了建立观点的“空间”。 而多视图方法背后的核心思想就与此有些类似： 从不同角度，规划“分割”与“交互”。 5视图方法包含如下几个视图： 逻辑视图 开发视图 运行视图 物理视图 数据视图 5个视图各有其“思维立足点”，分别是： 职责划分（逻辑视图） 程序单元组织（开发视图） 控制流组织（运行视图） 物理节点安排（物理视图） 持久化设计（数据视图） “思考最大的障碍在于混乱”。抓住每个视图的“思维立足点”。5视图方法就显得“相当清楚”了。 12.4.3. 详图：每个视图，一组技术关键点 接下来，看看架构师最关注的众多技术关注点，如何被5视图梳理的清楚。 例如，Layer是一种大粒度的“职责划分”单位，Layer的定义属于逻辑架构视图；而Tier则属于物理架构视图的考虑范围，它关注与硬件部署。 再例如，对于嵌入式系统而言，有经验的架构师能够从上图中“发现”自己的习惯做法： 控制流不仅仅包含进程和线程，中断服务程序也是一种重要的控制流机器（运行架构视图） 嵌入式应用数据的持久化常常基于文件（而不是数据库）的概念，最终常写入Flash（而不是硬盘）中（数据架构视图） ...... 如果说每个视图都是一个“语言”的话，那么视图内的那些技术关注点就是语言的“词汇”，正是这些不同的技术关注点支撑起不同的思维空间。 最后，看似复杂的5视图方法其实很简单，因为其每个视图都是从特定角度规划系统的分割与交互，都是（架构的定义）“组件 + 交互”的一种体现。--原来如此，提炼出了“繁”中之“简”，离成功运用这种方法就不远了！ "},"ch13/":{"url":"ch13/","title":"第13章. 逻辑架构","keywords":"","body":"第13章. 逻辑架构 有没有一种方法在大产品和小团队之间的缺口上架起一座桥梁呢？答案是肯定的，有！那就是架构。架构最重要的一点，就是它能把难以处理的大问题分解成便于管理的小问题。 -- Eric Brechner，《代码之道》 一流是每个程序设计人员向往并为之奋斗却又无法具体说出的、难以达到的境界，一流的软件非常简明。它灵活而清晰，能通过创造性的机制解决复杂的问题，这些机制语义丰富，可应用于其他可能完全无关的问题，一流意味着寻求恰当的抽象，意味着通过新的途径合理利用有限的资源。 -- Grady Booch，《面向对象项目的解决方案》 划分子系统、定义接口......，这些典型工作都是属于逻辑架构设计的范畴。 接下来，我们主要说说5视图方法中逻辑架构视图的设计： 先从划分子系统的3种必用手段讲起 随后，纠正“我的接口我做主”这种错误认识，代之以“协作决定接口”的正确理解 而且，接下来将解析逻辑架构设计的整体思维套路，解决架构师郁闷已久的“多视图方法只讲做什么、不讲怎么做”的问题 最后，总结逻辑架构设计的10条经验要点。 "},"ch13/13.1.html":{"url":"ch13/13.1.html","title":"13.1. 划分子系统的3种必用策略","keywords":"","body":"13.1. 划分子系统的3种必用策略 架构师最缺的不是理论，也不是技术，而是位于理论和技术之间的“实践策略”和“实践套路”。 就划分子系统这个架构师必须做的工作而言，其实实践策略可以归纳为3种： 分层的细化 分区的引入 机制的提取 13.1.1. 分层(Layer)的细化 分层是最常用的架构模式：在架构设计初期，100%的系统都可以用分层架构，就算随着设计的深入而采用了其他架构模式也未必和分层架构矛盾。 于是，架构师在划分子系统时常受到初期分层方式的影响--实际上，很多架构师最熟悉、最自然的划分子系统的方式就是：分层的细化。 3层架构或4层架构的“倩影”经常出现在投标时，或者市场彩页中，于是有人戏称之为“市场架构”。的确，直接用3层架构或4层架构来支持团队的并行开发是远远不够的。所以，“分层的细化”是划分子系统的必用策略之一，架构师们不要忘记。 13.1.2. 分区(Partition)的引入 序幕才刚刚拉开，划分子系统的工作还远远没有结束。 迭代式开发挺盛行，但所有真正意义上的迭代开发，都必须解决这样一个“困扰”：如果架构设计中只有“层”的概念，以“深度优先”的方式完成一个个具体功能就不可能的！ 所以，工程师们就经常遇到这样的烦恼 例如《代码之道》一书中就论及了这一点： 为了得到客户经常性的反馈，快速迭代有个基本前提：开发应该是“深度优先”，而不是“广度优先”。 广度优先极端情况下意味着每一个功能进行定义，然后对每个功能进行设计，接着对每个功能进行编码，最后才能对所有功能一起测试。而深度优先极端情况下意味着每个功能完整的进行定义、设计、编码和测试，而只有当这个功能完成之后，你才能做下一个功能。当然，两个极端都是不好的，但深度优先要好的多。对于大部分团队来说，应该做一个高级广度设计，然后马上转到深度优先的底层设计和实现上去。 为了支持迭代开发，逻辑架构设计中必须（注意是必须）引入分区。分区是一种单元，它位于某个层的内部，其粒度比层 要小。一旦架构师针对每个层进行了分区设计，“深度优先”式的迭代开发就非常自然。 ，支持迭代开发.png) 架构是迭代开发的基础。架构师若要在“支持迭代”方面不辱使命，必须注重“分区的引入”--这也是划分子系统的必用策略之一。 13.1.3. 机制的提取 Grady Booch在他的著作中指出： 机制才是设计的灵魂所在......否则我们就不得不面对一群无法相互协作的对象，它们相互推搡着做自己的事情而不关心其他对象。 机制之于设计是如此的重要。那么，什么是机制呢？ 那“机制”的定义是：软件系统中的机制，是指预先定义好的、能够完成预期目标的、基于抽象角色的协作方式。机制不仅仅包含协作关系，同时也包含了协作流程。 对于面向对象方法而言，“协作”可以定义为“多个对象为完成某种目标而进行的交互”，而“协作”和“机制”的区别可以概况为： 基于接口（和抽象类）的协作是机制，基于具体类的协作则算不上机制。 对于编程实现而言，在没有提取机制的情况下，机制是一种隐式的重复代码--虽然语句直接比较并不相同，但是很多语句只是引用的变量不同，更重要的是大段的语句块结构完全相同。如果提取了机制，它在编程层面体现为“基于抽象角色（OO中就是接口）编程的那部分程序”。 对于逻辑架构设计而言，机制是一种特殊的子系统--架构师在划分子系统时不要忘记这一点。最容易理解的子系统，是通过“直接组装”粒度更小的单元来是吸纳软件的”最终功能“。在实现不同的最终功能时，可以重用同一个机制，避免重复进行繁琐的”组装“工作。例如，网络管理软件中拓扑显示和告警通知都可利用消息机制。 13.1.4. 总结：回顾”三维思维“ 至此，我们讨论了划分子系统的3种手段：分层的细化、分区的引入、机制的提取。通过这3种手段的综合运用，就可更理性、更专业的展开逻辑架构的设计。 如何通过关注点分离来达到“系统中的一部分发生了改变，不会影响其他部分”的目标呢？ 首先，可以通过职责划分来分离关注点，面向对象的关键所在，就是职责的识别和分配。每个功能的完成，都是通过一系列职责组成的“协作链条”完成的；当不同职责被合理分离之后，为了实现新的功能只需构造新的“协作链条”，而需求变更也往往只会影响到少数职责的定义和实现...... 其次，可以利用软件系统各部分的通用性不同进行关注点分离。不同的通用程度意味着变化的可能性不同，将通用性不同的部分分离有利于通用部分的重用，也便于专用部分修改...... 另外，还可以先考虑大粒度的子系统，而暂时忽略子系统是如何通过更小粒度的模块和类组成的...... 总结了上述的架构设计关注点分离原理。可以说，根据职责分离关注点，根据通用性分离关注点，根据不同粒度级别分离关注点是三种位于不同“维度“的思维方式，所以在实际工作中必须综合运用这些手段。 于是，不难理解分层的细化、分区的引入、机制的提取这3种划分子系统手段之间的关系：它们处在思维的3个维度上。 首先，分层和机制位于不同的维度：职责维度和通用维度。 另外，是否引入分区，设计所“覆盖”的Scope是完全相同的。原因是层的粒度较大，而是层内部引入的分区的粒度更小，便于组合出一个个功能（支持迭代开发）。这是第三维：粒度。 看来，分层的细化、分区的引入、机制的提取这3个手段不是相互替代的关系，而是相辅相成的关系。 13.1.5. 探究：划分子系统的4个重要原则 重要的内容就值得多讲几遍。 下面的分层的细化、分区的引入、机制的提取这3种策略背后的4个通用设计原则： 职责不同的单元规划不同子系统 通用性不同的单元划归不同子系统 需要不同开发技能的单元划归不同子系统 兼顾工作量的相对均衡，进一步切分到多个原则综合作用的结果 "},"ch13/13.2.html":{"url":"ch13/13.2.html","title":"13.2. 接口设计的事实与缪误","keywords":"","body":"13.2. 接口设计的事实与缪误 世界是复杂的，很多东西难以直接获取。 例如直接最强幸福，是永远追不到的（《乐在工作》一书中说幸福是副产品）。 殊不知，合理的接口设计也不是“直接”得到的。 由于面向对象非常强调“自治”，许多人不知不觉的形成了一种错误认知：面向对象推崇“我的接口我做主”。很遗憾，“自治”正确。但“我的接口我做主”这个推断是错误的。 软件世界中本无模块。1968年，Dijkstra发表了第1篇关于层次结构的论文《The Structure of THE-multiprogramming System》（原文PDF）。1972年，Parnas发表论文《On the Criteria To Be Used in Decomposing Systems into Modules》论及了模块化和信息隐藏的话题......这是架构学科开始萌芽的标志。 那么，为什么要对软件进行模块化设计呢？是为了解决复杂性更高的大问题。于是，我们突然领悟：对问题进行分解，分别解决小问题，其实这只是手段。每个架构师应该牢记： “分”是手段，“合”是目的。不能“合”在一起支持更高层次功能的模块，又有何用呢？ 因此，我们必须把模块放在协作的上下文之中进行考虑。架构师设计接口时，要考虑的重点是“为了实现软件系统的一系列功能，这个软件单元要和其他哪些单元如何协作”，总结成一句话就是： 协作决定接口 相反，直接设计接口，是很多“面向接口的”架构依然拙劣的原因之一。类似“我的接口我做主”的观点是错误的，每个模块或子系统（甚至类）无视协作需要而进行的接口定义很难顺畅的被其他模块或子系统使用。 "},"ch13/13.3.html":{"url":"ch13/13.3.html","title":"13.3. 逻辑架构设计的整体思维套路","keywords":"","body":"13.3. 逻辑架构设计的整体思维套路 13.3.1. 整体思路：质疑驱动的逻辑架构设计 要点如下： 质疑驱动 结构设计和行为设计相分离 模板不是一天建成的。需求对架构设计的“驱动”作用，是伴随着架构师“不断设计中间成果 -> 不断质疑中间成果 -> 不断调整完善细化中间成果”的过程渐进展开的。打个比方，需求就像“缓释胶囊”，功能、质量、约束这3类“药物成分”的药力并不是一股脑释放的，而是缓缓释放的--“缓释”的控制者必然是人，是架构师 “药力释放机理” -- 逻辑架构设计的整体思维套路 先考虑结构方面的切分。手段是上面所讲的分层的细分、分区的引入、机制的提取。 然后，让切分出的职责协作起来，验证能否完成功能。这个工作，可以借助时序图进行。 此时，结构和行为方面各进行了一定的设计，就应开始质疑自己的设计。架构师要从两个角度质疑： 功能方面，特殊的功能支持吗？ 质量方面，耦合性、重用性、性能等怎么样？ 如此循环思维，不断将设计推向深入......其间，会涉及接口的定义，建议用“包-接口图”作为从结构到行为过度的桥梁，从而识别接口。至于接口的明确定义（接口包含的方法为何），则要进一步考虑基于职责的具体交互过程。 13.3.2. 过程串联：给初学者 第1步，根据当前理解切分。质疑驱动的逻辑架构设计整体思路，是从运用分层的细化、分区的引入、机制的提取进行子系统划分开始。 第2步，找到某功能的参与单元。弱找不到明显缺单元，就可以直接返回到第1步，以补充遗漏的职责单元。 第3步，让它们协作完成功能。研究第2步找到的参与单元之间的协作关系，看看能否完成预期功能，完成的怎么样？ 第4步，质疑并推进设计的深入。通过质疑“对不对”和“好不好”，可以发现新职责，或者调整协作方式。这意味着，第1步的子系统切分方案被调整、被优化......如此循环。 13.3.3. 案例示范：自己设计MyZip MyZip的概念架构设计，它将和需求一起，影响MyZip的细化架构设计。 下面主要是演示如何以质疑驱动的思路，设计MyZip的逻辑架构视图。 首先，考虑结构方面的切分，3种划分子系统的手段都运用上。 分层的细分。压缩实现层从原来的压缩控制层中分离出来。回忆一下之前的“子系统划分策略背后的4大原则”。无论是从职责不同的角度，还是从所需技能的角度考虑，两者都应该分离成为单独的“子系统”。 分区的引入。界面交互层必须进一步分区，例如：支持右键菜单的“Windows外壳扩展”部分被独立。 机制的提取。例子是智能缓冲机制，它应该成为一个通用性的基础子系统。同时，为了使它可重用，缓冲区不负责“缓冲区已满”时的具体处理而是毁掉外部单元进行。再者，为了提高使用友好性，缓冲区具有一定“智能”，它会自动保存溢出的部分，从而简化使用缓冲区的接口。 然后，让切分出来的职责协作起来，验证能否完成功能。我们来回答“切分之后的结构能支持压缩的协作吗？”的问题。回忆一下之前提到的增量建模技巧--不要急于“一口吃个胖子”。 如此循环，早晚要定义子系统的接口。下面是包-接口图，帮助架构师明确需要哪些接口（还没有到接口内方法定义一级）。 再次从结构设计跳到行为设计。现在在该更明确考虑压缩了。接下来，我们要演示ZipOneFile的设计。同样，遵循“先大局，后局部”的设计原则。具体设计决策是，让“控制”担当ZipOneFile的职责，而不是让“压缩实现”来担负--原因是希望“压缩实现”不须感知File的概念而能够更大程度上的被重用(例如对数据包而非文件进行压缩)。 我们来进一步的明确接口的方法定义...... "},"ch13/13.4.html":{"url":"ch13/13.4.html","title":"13.4. 更多经验总结","keywords":"","body":"13.4. 更多经验总结 13.4.1. 逻辑架构设计的10条经验要点 我们归纳了逻辑架构设计的10条经验要点，其中，如何划分子系统，如何定义接口，如何运用质疑驱动的事物套路等已经介绍，其他几点再继续简单介绍。 划分子系统：分层的细化 划分子系统：分区的引入 划分子系统：机制的提取 接口的定义：协作决定接口 选用序列图：杜绝协作图 包-接口图：从结构到行为的桥 灰盒包图：描述关键子系统 循序渐进的螺旋思维 设计模型：包内结构 设计模式：包间协作 13.4.2. 简述：逻辑架构设计中设计模式应用 设计模式是Class Level的设计，它如何用于架构一级的设计呢？ 基本观点是：让Class和SubSystem搭上关系。不难理解，设计模式用于架构设计主要有两种方式： 明确子系统内的结构 明确包间的协作关系 如何做呢？答案是灰盒包图。下图中说明了灰盒包图的意义，它打破了“子系统黑盒”，关系子系统中的关键类，从而可以更到位的说明子系统之间的协作关系，并成为设计模式应用的基础。 例如，我们对比一下黑盒包图和灰盒包图（背景是项目关系系统甘特图展示的问题）。后者明确了子系统之间的交互机制，还显式的说明了Adpter设计模式的应用--这就是灰盒包图的价值。 13.4.3. 简述：逻辑架构设计的建模支持 工欲善其事，必先利其器。在实践中必须选择最适合的模型，甚至做一些改造工作让UML更适合特定的实践目的。例如：灰盒包图就是一种“专门说明重要子系统设计”的UML图的应用。 另外，包-接口图是类图的一种特定形式，它包含“包（package）”和“接口（interface）”两种主要元素。这种图的作用很专一：说明包之间的协作需要哪些接口。逻辑架构设计中，包-接口图是从结构设计到行为设计的思维桥梁。 最后，“逻辑架构设计的整体思维套路”时已亮明了观点：逻辑架构的设计，应该使结构设计和行为设计相分离。这样才利于更有效的思维。不信？请看下面所示的“设计图”（这是很多设计者习惯的思维方式）。思维清楚吗？思维混乱的原因：将结构和行为过多的混在了一起。 推荐用时序图（它较为专注于行为设计）辅助逻辑架构设计，尽量不要用协作图（虽然在UML 1.4中，它和时序图等价，但从形式上它的“结构气”太重）。 "},"ch13/13.5.html":{"url":"ch13/13.5.html","title":"13.5. 贯穿案例","keywords":"","body":"13.5. 贯穿案例 我们来继续贯穿案例：PASS系统的架构设计。首先应注意两点： 第一，细化架构的重要“输入”之一是概念架构设计，不应忽视，比较细化架构设计是整个架构设计过程中的一个阶段。例如，之前进行的“基于鲁棒图的初步设计”，以及“高层分割考虑”。 第二，5视图方法的运用，总体而言是5个视图的设计穿插进行的，对复杂系统而言，根本不可能将逻辑视图设计完全之后再考虑其他视图。而本案例的PASS系统具有很强的分布特点，所以必然较早的考虑到物理视图对逻辑设计的影响。例如，PASS服务器作为一个物理架构元素的“节点(Node)”，它之上“跑”的逻辑架构“逻辑层(Layer)”有哪些呢？ 进入细化架构阶段的逻辑架构设计，常以初步设计为基础，借助分层细化、分层引入、机制提取等手段。对PASS服务器软件进行逻辑架构的结构设计。 从结构设计跳到行为设计，常用手段是画时序图。它处于逻辑架构设计的“螺旋式”整体思维讨论的起始循环，是进一步深入设计的基础。 有了不同职责单元之间具体的协作关系，就可以展开细致的“质疑”了--别忘了，架构设计是质疑驱动的。 处方检查服务能被医生工作站访问到吗？毕竟前者位于PASS服务器上......于是，设计中要进一步明确“远程调用机制”。 这样一个分布式的系统，访问服务之前要经过什么样的验证呢......于是，进一步考虑安全性的支持。 不同的医生不停的开处方，处方检查功能会不会很慢？常用药的用药规则应该常驻内存，这样才能提升性能......于是，设计要进一步明确Cache等提升性能的机制。 ...... 于是，自然而然地，沿着逻辑架构设计的“螺旋式”整体思维套路思考，我们就能意识到“结构设计”要继续完善和细化。基于对远程调用、安全性、高性能的质疑，改进的“结构设计”后就得到下面的逻辑架构图。 "},"ch14/":{"url":"ch14/","title":"第14章. 物理架构、运行架构、开发架构","keywords":"","body":"第14章. 物理架构、运行架构、开发架构 我认识一些架构师，他们的生活都是失控的。因为架构天性范围宽广，涉及人、工作量都非常多。一些架构师把他们的时间整天整天的花在跟“项目干系人”开会上，然后夜以继日，再搭上周末去实际的架构工作。 -- Eric Brechner, 《代码之道》 多重软件架构视图之所以必不可少，是因为各类涉众（用户、客户、开发人员、测试人员、维护人员、内部操作人员、其他人员）需要从各自角度理解和使用架构。 -- Barry Boechm 架构要涵盖的内容和决策太多了，超过了人脑“一蹴而就”的能力范围，因此采用“分而治之”的办法从不同视角分别设计；同时，这样也为对软件架构的理解、交流和归档提供了方便。 接下来会介绍物理架构、运行架构、开发架构作为软件架构的不同视图，它们分别关注不同的方面、针对不同的目标和用途。 "},"ch14/14.1.html":{"url":"ch14/14.1.html","title":"14.1. 为什么需要物理架构","keywords":"","body":"14.1. 为什么需要物理架构 硬件强大了，但数据量在增加，计算复杂度也在提高，所以增加硬件未必能解决问题。 相反，计算与计算往往不是孤立的，它们之间存在着复杂的“生产者-消费者”关系，所以软件的实际服务能力不仅受到“硬件资源”的制约，也受到了“数据短缺”和“数据争用”的制约。每个架构师都应该懂得： 增加硬件 = 增加计算能力 ≠ 软件的实际服务能力增强 多视图方法中，物理架构视图着重考虑运行软件的计算机、网络、硬件设施等情况，还包括如何将软件包部署（如果是嵌入系统则是烧写）到这些硬件资源上，以及它们运行时的配置情况。另外，物理架构还要考虑软件系统和包括硬件在内的整个IT系统之间是如何相互影响的，由于一部分运行质量属性需要硬件或网络的支持，所以物理架构必须关注如何配置硬件和网络来满足软件系统的可靠性、可伸缩性、持续可用性、性能、安全性等方面要求。 "},"ch14/14.2.html":{"url":"ch14/14.2.html","title":"14.2. 物理架构设计的工作内容","keywords":"","body":"14.2. 物理架构设计的工作内容 物理架构设计主要有3项任务： 硬件选择和物理拓扑 软件到硬件的映射关系 方案的优化 "},"ch14/14.3.html":{"url":"ch14/14.3.html","title":"14.3. 探究：物理架构的设计思维","keywords":"","body":"14.3. 探究：物理架构的设计思维 相对逻辑架构设计而言，物理架构视图的设计是不是就乏善可陈呢？不，一般架构师最缺的就是物理架构的设计思路。 从设计结果层面，决策无非围绕物理节点、网络、软件单元、数据单元等内容展开。 但是，思维当中经历了哪些思考、判断和权衡呢？ 从最终目标层面，决策要兼顾多方涉众的不同利益，可从“攻”与“守”两个方面理解： 高性能（攻） 持续可用性（攻） 可伸缩性（攻） 技术可行性（守） 易维护性（守） ...... 从思维要点层面，“开销”和“争用”是核心。架构师正是通过“降低开销”、“避免争用”来实现高性能、高伸缩性等最终目标。 如何降低物理节点“内”的计算开销？ 如何降低物理节点“间”的通信开销？ 如何避免物理节点“内”CPU、内存、硬盘等资源的争用？ 如何避免物理节点“间”网络的带宽资源冲突？ 这样，我们了解了物理架构设计的理性思维框架。 "},"ch14/14.4.html":{"url":"ch14/14.4.html","title":"14.4. 为什么需要运行架构","keywords":"","body":"14.4. 为什么需要运行架构 如果系统中，并不准备引入任何并行或并发处理，并且系统也没有基于SDK、API等基础软件进行定制开发，那就不需要设计运行架构的设计--这相当于将5视图方法裁剪为4个视图。 相反，很多系统为了应对复杂的业务逻辑或复杂的互操作逻辑（含硬件交互），或者为了优化关键资源使用效率，而必须借助多条控制流或并发执行时，就需要设计运行架构。 "},"ch14/14.5.html":{"url":"ch14/14.5.html","title":"14.5. 运行架构设计的工作内容","keywords":"","body":"14.5. 运行架构设计的工作内容 14.5.1. 工作内容 根据具体情况不同，运行架构设计可能包括下列工作内容 确定引入哪些控制流 确定每条控制流的任务 处理相关问题：控制流的创建、销毁、通信机制等 进一步考虑：控制流之间的同步关系，若有资源争用还要引入加锁机制 控制流（Control Flow）是一个在处理机上顺序执行的动作系列。确定引入哪些控制流，并没有固定不变的套路，但有几点考虑是必不可少： 物理架构中的每个节点（node）之上至少有一条控制流 为了实现节点（node）之间的通信，通常做法是引入一条控制流来专门负责 在需求一级的描述中（例如用例规约中）就是并行或并发的，引入多条控制流 来自用户或外部系统的并发访问，常要求后端服务支持多控制流 如果控制流关系复杂，可以考虑引入对其他控制流进行协调的控制流 一旦系统中存在不止一条控制流，就产生了附近的工作量，例如控制流的创建、控制流的销毁、建立共享内存或消息等不同控制流之间的通信机制。 14.5.2. 控制流图是关键 控制流图显示了系统中不同控制流之间的关系。控制流的起点是“主动单元”，它会调用其他“被动单元”......如此层层调用，就形成了一个控制流。明确了系统中所有的主动单元，就抓住了每个控制流的源头，从而可以把并发执行的所有控制流梳理清楚。 例如：M和N两个模块可能需要加锁，因为M模块的“入度”等于2，而N是M的下游模块。 运行架构设计的工作看似多而杂，但其实只要把握“控制流图”，就能提供提纲擎领的开展其他相关设计。 "},"ch14/14.6.html":{"url":"ch14/14.6.html","title":"14.6. 实现控制流的3种常用手段","keywords":"","body":"14.6. 实现控制流的3种常用手段 在实践中，最常用于实现控制流的手段有3种。 进程 线程 中断服务程序 进程（Process）是重量级控制流，即是处理机资源的分配单元，又有其他计算机资源的分配单位。 线程（Thread）是轻量级控制流，仅仅是处理机资源的分配单位。一个进程内可以包含多个线程，后者共享前者的资源：但处理机资源例外，线程是独立IDE处理机资源的分配单位。 实际上，中断服务程序（Interupt Service Routine, ISR）也是常见的控制流实现机制。当没有OS的支持却要实现并发时，它非常必要。 例如，下图所示的多条控制流设计用到了线程，以及中断服务程序的技术（背景为设备调试系统）: 应用层中的线程代表主程序的运行，它直接利用了MFC的主窗口线程。无论是用户交互，还是串口的数据到达，均采用异步事件的方式处理，杜绝了任何“忙等待”无谓的耗时，也缩短了系统响应时间。 协议层有独立的线程控制着“上上下下”的数据，并设置了数据缓冲区，使数据的接受和数据的处理相对独立，从而使数据接收不因暂时的处理忙碌而停滞，增加了系统吞吐量。 硬件控制层的设计中，分别通过时钟中断和RS232中断来激发相应的处理逻辑，达到轮询和收发数据的目的。 "},"ch14/14.7.html":{"url":"ch14/14.7.html","title":"14.7. 为什么开发架构是必须的","keywords":"","body":"14.7. 为什么开发架构是必须的 以前，很多企业不重视架构：现在，重视架构的企业远比不重视架构的企业多。但是，许多企业发现一个棘手的问题：开发人员不按照架构进行详细设计和编程。 大家一起来思考下面的问题。 问题，许多公司困扰于：开发人员不按照架构进行详细设计和编程。如何让开发人员更“拥护”架构？ A： 在架构设计中重视“开发架构视图”，让开发人员看到他最关心的“程序单元”、“源代码目标结构”等概念 B：架构设计不可“高来高去”，能支持并行的详细设计是“架构设计你进行到什么程度”的标志 C：应令HR对开发人员批评、教育 D：编程一线的程序经理参与架构设计 此题的答案是：A、B、D 一句话，架构师在抱怨研发管理、职位权力之前，还需自查！ 首先，最基本的一点，架构师必须重视开发架构视图，并行开发所需的“程序单元”、“源码目录结构”等概念，是不同程序团队开展具体工作的基础。如果程序员们总不能从架构中农看到上述内容，就会认为架构是一类“高来高去”的概念，自然不会有积极态度。（A 正确） 另外，能不能更具体的“定义”架构设计应该达到的程度呢？答案是：能支持并行的详细设计。所以，架构师投标成功之后，切不可将投标中演示的“市场架构”直接作为架构设计的全部。因为这意味着很多影响全局的设计决策被“漏”到了后边，最终到大规模并行开发阶段才发现，造成“程序员碰头临时决定”的情况大量出现，必然导致软件质量下降甚至项目失败。（B正确） 当然，有能力的架构师，再加上聪明的管理策略就更好。既然每个程序经理都深入理解架构，那何不让他们参与到架构实践的工作中来，免去了大量“单纯的架构交流”的工作量。更不必说，“了解产生爱”（程序人员不了解你的架构又如何喜欢你的架构）和“成就感”的心理因素会让程序经理支持架构设计方案。（D正确） "},"ch14/14.8.html":{"url":"ch14/14.8.html","title":"14.8. 开发架构设计的工作内容","keywords":"","body":"14.8. 开发架构设计的工作内容 一般而言，开发架构的设计应完成下列工作。 将“逻辑职责”映射为“程序单元” 要自主编写的源程序 可重用的库、框架 其他方式(如Shell脚本、平台支持下的配置文件) 开发技术选型 开发语言 开发工具 “程序单元”间关系 Project划分（可选） Project目录结构 编译依赖关系 值得说明的是，此处的“Project”不是指Project Manager管的“项目”，而是指IDE等开发环境所支持的“Develop Studio Project”类似的概念。 "},"ch14/14.9.html":{"url":"ch14/14.9.html","title":"14.9. 观点：重用测试是关键","keywords":"","body":"14.9. 观点：重用测试是关键 广大软件企业系统通过为客户提供合格的软件系统达到获取利润的目标，于是，他们非常关注“可重用性”。但从重用的现实效果来看，显然远远不能令人满意...... 14.9.1. 探究：我们为何年复一年修改者类似的Bug 在很多企业（包括很多程序员本人）都声称“我们很重视重用”的背景之下，下面这个问题尤其值得深思： 国内许多程序员年复一年的写着类似的程序--更要命的是，他们年复一年的修改者类似的Bug。 事出有因。以下两个问题是根源所在。 第一，架构师“重交付、轻维护”。心理学告诉我们，自己的、眼下的痛苦是最大的痛苦。于是，在工期的巨大压力下，许多架构师最担心的是“项目能否按时交付”，于是就把维护问题仍在脑后。 第二，架构师“重视小粒度重用、忽视大粒度重用”。一个孤立的类、一个小函数，每天都能被重用，却不能解决“年复一年修改类似Bug”的问题。最终我们发现，小粒度重用是有价值的，但和大粒度重用并不矛盾，而大粒度重用才是避免“重复组装、重复改Bug”式浪费的关键。 所以，请记住这个公式： 重用价值 = 重用次数 x 单次价值 14.9.2. 观点：为了从根本上降低维护成本，重用测试是关键 不要只关心重用的次数，为了重用而重用，而是时刻关注节省成本--这才是重用的目标所在。于是，当我们想到“维护是最昂贵的环境”，当我们看到经典书籍显示维护成本占总成不的67%之巨时，会作何感想？ 图片来源：App Maintenance Cost Can Be Three Times Higher than Development Cost 想必你的结论和我一样：为了从根本上降低维护成本，重用测试是关键。这意味着大粒度重用。也就是，在重用这些代码时，并不对代码任何修改--它们的测试也被重用了。具体而言，Framework、Service、Server、平台、中间件都算大粒度重用技术，它们已经成为，并继续是重用技术的未来方向。 14.9.3. 简评：设计模式对重用的意义 最后，评论有一个有趣的现象：很多架构师一提到重用首先会想到设计模式。那么，设计moose在重用技术中占据了什么位置呢？先看看Lethbridge在《面向对象软件工程》中的一段话： 下面是软件工程师实践过的一些重用类型，安装重用所节省的潜在工作量的升序排列。 重用专家经验 重用标准的设计和算法 重用类库或程序，或者重用语言和操作系统中内置的强大命令 重用框架 重用完整的应用程序 设计模式属于上面的“专家经验”和“标准的设计”级别的重用策略--《面向对象软件工程》明白无误的告诉我们：这种“重用类型”节省的潜在工作量是比较有限的。 为什么呢？下图说明了“设计模式”和“框架”等技术在重用方面区别的根源：前者通用程度高和编程语言无关，后者实现程度高代码已提供。没有代码--无论是系统软件或平台内部的实现，还是库或者框架这种外部实现--就没有办法重用测试，就会面临较多的Bug而花费较高的维护成本。 "},"ch14/14.10.html":{"url":"ch14/14.10.html","title":"14.10. 贯穿案例","keywords":"","body":"14.10. 贯穿案例 继续PASS系统的架构设计。 14.10.1. 物理架构 回顾之前第9章的“贯穿案例”部分，你可能会有疑问：物理架构不是在概念架构时已设计吗？为什么又要设计？ 所以，下面首先分析医学：概念架构设计和5视图方法是什么关系。 总体而言，概念架构所包含的高层设计决策终究不会跳出5个架构视图的范围--逻辑架构、物理架构、开发架构、数据架构或运行架构 只不过，概念架构设计的抽象程度比较高，设计程度也很不充分，而细分架构必须设计到可以指导开发的程度 例如，一个分布式系统的概念架构，最常见的做法是包含逻辑架构和物理架构2个视图的高层次的考虑 对于典型的嵌入式控制习题而言，概念架构设计时又经常运行架构中多条控制流的规划 总之，概念架构与5视图方法的区别及联系可以用两句话概况。 概念架构从少数视角、重点视角进行概念设计 细化架构从多个视角、全面视角进行充分设计 至此，我们明白了PASS系统的物理架构设计已经在概念架构时进行了一部分，进一步明确不同物理层(Tier)之间的协议类型、每一物理层是否需要部署集群、软件单元（例如Layer）到物理节点的映射关系等物理架构设计的内容即可。 14.10.2. 持续不断的考虑非功能需求 非功能需求的支持不可能是“速决战”。 非功能需求的考虑是“贯穿环节”，在概念架构设计阶段，以及细化架构设计阶段都应重视。 对细化架构设计阶段而言，这意味着非功能目标的考虑时刻伴随着5视图的设计。例如，为了支持“用药规则的实时更新”这一功能，会涉及不同视图的考虑，中间穿插着无数次“质疑-分析-决策”的“微过程”。 我们通过“目标-场景-决策表”来“重放”了我们的思维过程。 14.10.3. 开发架构 对大系统而言，开发架构设计中的“Project划分”是不可或缺的，因为即使一个Project可以“胜任”（例如没有多节点因素），我们也不推荐这样做。更何况，将一个系统组织成多个Project的形式进行开发，可以方便的单独控制每一个Project源码的保密性--这是很多软件企业都关心的一个问题。 我们将PASS系统划分为5个Project，分别为： 院长Web应用 管理员Web应用 嵌入式工作站的DLL 医生模块通用SDK PASS Server 确定了PASS系统划分成哪几个Project，就可以进一步确定每个Project所包含的程序单元、这些程序单元的依赖关系、源码的基本结构等问题，并为每个Project选定具体的技术及所用到的Framework。 14.10.4. 架构设计应进行到什么程度 最终，架构设计应进行到什么程度呢？ 架构设计的程度应考虑3方面的问题。 应为开发人员提供足够的指导和限制 标志：可支持并行的详细设计 说明：所谓架构设计、概要设计、总体设计，只是含义相同的不同词汇而已。因此，“架构设计->概要设计->详细设计”的观点是不够专业的 解图：图中“架构设计”和“详细设计”之间没有缝隙 因项目、开发团队情况的不同而变化 说明：应考虑项目熟悉程度、风险高低，以及团队技能水平等 解图：图中“架构设计”的“详细设计”之间的“线”上下浮动 业务层、通用机制应更深入设计 说明：核心模型影响可扩展性，应当更深入设计；通用机制影响易解性和Bug率，应当更深入设计 解图：图中“架构设计”和“详细设计”之间的“线”为深深浅浅的锯齿状 "},"ch15/":{"url":"ch15/","title":"第15章. 数据架构的难点：数据分布","keywords":"","body":"第15章. 数据架构的难点：数据分布 压力、没时间进行充分测试、含糊不清的规格说明......无论多努力工作，还是会有错误，不过，造成无法挽回失败的，是数据库设计错误还是架构选择错误。 -- Stéphane Faroult，《SQL语言艺术》 针对不同的领域，由于信息资源类型及其存在的状态不同，信息资源整合的需求存在较大差异。 -- 彭洁，《信息资源整合技术》 确定数据分布方案是数据架构设计的难点。越是大系统，数据分布越关键。因此，一线架构师迫切须要建立数据分布策略的大局观。 我们接下来结合案例，讲讲如何运行数据分布的6种具体策略。 "},"ch15/15.1.html":{"url":"ch15/15.1.html","title":"15.1. 数据分布的6种策略","keywords":"","body":"15.1. 数据分布的6种策略 所谓分布式系统，不单单是程序的分布，还涉及数据的分布。而且，处理数据分布内容常常更加棘手。 根据系统数据产生、使用、管理等方面的不同特点，常采用不同的数据分布式存储与处理手段。总体而言，可以归纳为以下6种策略： 独立Schema(Separate-schema) 集中(Centralized) 分区(Partitioned) 复制(Replicated) 子集(Subset) 重组(Reorganized) 15.1.1. 独立Schema(Separate-schema) 当一个大系统由相关的多个小系统组成，且不同小系统具有互不相同的数据库Schema定义，这种情况称为“独立Schema”。 独立Schema方式的理解要点：“Application不同，Schema不同”。 如果可以，架构师应首选此种数据分布策略，以减少系统之间无谓的相互影响，避免人为的将问题复杂化。 15.1.2. 集中(Centralized) 指一个大系统必须支持来自不同地点的访问，或者该系统由相关的多个小系统组成，而持久集中化数据进行集中化的、统一格式的存储。 该方式的特点可用 “集中存储、分布访问” 来概括。 15.1.3. 分区（Partitioned） 分区方式包含水平分区和垂直分区两种类型。 当系统要为“地域分布广泛的用户”提供“相同的服务”时，常常采用水平分区策略。水平分区的特点可用概括为 “两个相同，两个不同” -- 相同的应用程序、不同的应用部署示例(instance)，项目的数据模型、不同的数据值。 在实践中，水平分区的应用非常广泛，而垂直分区的作用相比之下要小很多。下图说明了垂直分区方式的特点： 不同数据解读的Schema会有“部分字段（Field）”的差异，但可以从同一套总的数据Schema中抽取得到。 另外，需要特别说明的是，“分区”不是指DBMS支持的“分区”内部机制--后者作为一种透明的内部机制，编程开发人员感觉不到它的存在，常由DBA引入；而当前所讲的“分区”会影响到编程开发人员，或者应用部分工程师，一般由架构师引入。 15.1.4. 复制（Replicated） 在整个分布式系统中，数据保存多个副本，并且以某种机制（实时或快照）保持多个数据副本之间的数据一致性，这就是复制方式的数据分布策略。 15.1.5. 子集(Subset) “子集”是“复制”的特殊方式，就是某节点因功能或非功能考虑而保存全体数据的一个相对固定的子集。 总体而言，子集方式和复制方式有着非常类似的优点： 通过数据“本地化”，提升了数据访问性能 数据的专门副本，利于有针对性的进行优化（例如：支持大量写操作的DB副本应减少Index，而已读为主的DB副本可设更多Index） 数据的专门副本，便于提高可管理性，加强安全控制 不过，实践中常优先考虑子集方式，因为它与复制方式相比有两大优势： 减少了跨机器进行数据传递的开销 减低了数据冗余，节省了存储成本 15.1.6. 重组（Reorganized） 业务决定功能，功能决定模型。当遇到数据模型不同时，一般能够从功能差异的角度找到答案。 重组这种数据分布策略，就是不同数据节点因要支持的功能不同，而以不同的Schema保存数据--但本质上这些数据是同源的。于是，重组策略需要进行数据传递，但不是数据的“原样”复制，而是以“重新组织”的格式进行传递或保存。 根据典型的应用场景，重组可以分为两种类型： 统计性重组 结构性重组 例如，总工时只需要掌握分公司的财务、生产等概况信息，那么就不需要把下面的数据原样复制到总公司节点，而是通过分公司应用对信息进行统计后上报，这叫“统计性重组” -- 数据的重新组织较多的借助了抽取、统计等操作，并形成了新的数据格式。 “结构性重组”的例子，最典型的就是BI系统。生产系统的数据被整合重组，增加各种利于查询的维度信息，并以新的数据Schema保存提供BI应用使用。 "},"ch15/15.2.html":{"url":"ch15/15.2.html","title":"15.2. 数据分布策略的大局观","keywords":"","body":"15.2. 数据分布策略的大局观 没有大局观，就很难理性选择数据分布的策略。因此，我们来总体对比6种数据分布策略的相同点及不同点。 15.2.1. 6种策略的二维比较图 一图胜千言，再次借助图来揭示“复杂背后的简单”。 根据系统的特点不同，架构师所规划的数据分布策略无非为两种方式： 非复制方式 复制方式 非复制包括3种具体策略： 集中 分区 独立Schema 复制方式也包括3种具体策略： 复制 子集 重组 另一个对比视角是：数据节点的Schema是否相同。其中，独立模式和重组两种方式，像它们的名字暗示的那样采用了不同的数据Schema，而集中、分区、复制、子集这4种方式统一使用了相同的数据Schema。 15.2.2. 质量属性方面的效果对比 选择数据分布策略，应特别关注它们在质量属性方面的效果。 下面来整体看看哪些策略分布在可靠性、可伸缩性、通信开销、可管理性，以及数据一致性等方面表现最佳。 可靠性冠军：复制。冗余不利于修改，但有利于可靠性。总体而言，复制方式的数据分布策略是可靠性的冠军。 其实，复制方式的可靠性和最终的“复制机制”密切相关，例如每天以快照方式来同步数据，不如实时同步的可靠性高。 可伸缩性关键：（水平）分区。Scale Up会随着服务规模的增大变得越来越昂贵，而且它是有上限的。对超大规模的系统而言，Scale Out是必由之路。而（水平）分区的数据分布策略非常方便支持Scale Out。 有的文献上说“复制”方式对可伸缩性的支持也非常高，这种观点只对了一半--当数据以只读式消费为主时，通过复制增加服务能力的效果才好，否则为保证数据一致性而进行的“写复制”会消耗不少资源。 通信开销冠军：独立Schema。独立Schema“得这个奖”是实至名归的。这很容易理解，既然独立Schema方式强调“将一组数据与它关心密切的功能放在一起”的高聚合原则 ，那么覆盖不同功能范围的应用之间就是松耦合的--用于传递数据的通信开销自然就小了。 可管理性冠军：独立Schema。是的，还是它！由专门的数据Schema分别致辞不同的应用功能，它们是相对独立的，便于进行备份、调整、优化等管理活动。 因此，前面提到过：“如果可以，架构师应首选此种数据分布策略，以减少系统之间无谓的相互影响，避免人为的将问题复杂化。” 可管理性冠军（并列）：集中。为什么会存在“并列冠军”呢？因为从觉得角度评价可管理性是没有实际意义的。对采用了“数据大集中”的超大型系统而言，数据中心的管理工作依然具备挑战性，但相对于分散的存储方式而言可管理性已大有改观。可管理性应该视原始问题的复杂程度而论，是相对的，而不是绝对的。 数据一致性冠军：集中。所有用户面对同样的数据，免去了修改同一数据不同实例的“麻烦”，便于保证数据的一致性。 "},"ch15/15.3.html":{"url":"ch15/15.3.html","title":"15.3. 数据分布策略的3条应用原则","keywords":"","body":"15.3. 数据分布策略的3条应用原则 现在，我们已经全面了解数据分布的6种策略。下面，我们借助案例介绍数据分布6大策略的3条应用原则： 把握系统特点，确定分布策略（合适原则） 不同分布策略，可以综合运用（综合原则） 从“对吗”、“好吗”两方面进行评估优化（优化原则） 15.3.1. 合适原则 合适的才是最好的。“把握系统特点，确定分布策略”，这是再明白无误的基本原则了。 医疗信息化中的电子病历可以复制，而各种系统常涉及的身份管理信息最忌讳复制。但为什么呢？ 一句话，这是由系统的特点决定的。病历常作为医生诊断和治疗疾病的依据，是很有价值的资料。通过电子病历，可以将医务人员对病人患病经过和治疗所做的文字记录数字化，因此，电子病例的基本内容属于只读数据。为解决下列问题，电子病历可采用复制策略（例如在全网设置3个电子病历数据中心）： 各医院地域分布广，容易受到各种网络传输问题的干扰 如果不能使用专网，还要考虑“跨网络”性能差的问题 相反，身份管理信息不适合采用复制方式。用户信息有很强的修改特性： 新用户注册，意味着将有数据Insert操作 用户修改密码或其他信息时，将有Update操作...... 这时，如果采用复制，会造成大量数据同步操作。 所以，身份管理信息要集中，电子病历可以通过复制来提升性能和可访问性。 15.3.2. 综合原则：服务受理系统 vs 外线施工管理系统案例 当系统比较复杂时，其数据产生、使用、管理等方向可能很难表现出“压倒性”的特点。此时，就需要考虑综合运用不同数据分布策略。 电信BOSS（业务运营支撑系统）是电信运营商的一体化支持系统，它主要由网络管理、系统管理、计费、营业、账务和客户服务等部分组成。信息资源共享是BOSS规划是的核心问题之一。 其中自己“服务受理系统”和“外线施工管理系统”两个系统所覆盖的业务是相对独立的，各有自己的业务数据，采用“独立Schema”这种数据分布策略非常合适。至于两个系统之间存在互操作的关系，通过远程服务调用等形式支持即可。 单就“S市电信服务受理系统”而言，应采用什么数据分布策略呢？考虑系统欲达成到以下目标： 服务受理系统，应提供跨全市各辖区的、统一的服务。这意味着，在全市任何一家营业厅，都应该可以受理任何一个小区的电话开通业务。 例如，一个客户在浦东区居住，但在杨浦区上班，服务受理系统必须支持该客户在杨浦区申请开通浦东区某小区的一部固定电话。 ...... 所以，数据应集中。 再考虑“外线施工管理系统”。从业务角度，外线工作还是典型的“划片分管”模式，一般由支局负责。所以，推荐外线施工管理系统“开发一套，多点部署”--数据分布策略是：水平分区。 总结一下，本例综合应用了3种数据分布策略 独立Schema--服务受理系统和外线施工管理系统的数据相互独立 数据集中--服务受理系统 水平分区--外线施工管理系统 15.3.3. 优化原则：铃声下载门户案例 架构设计是一个过程，合理的架构往往需要团队甚至外部的意见，因此注重优化原则很重要。一个有用的技巧是：当难以“一步到位”的做出数据分布策略的正确选择，以及还存在质疑时，应从“对吗”、“好吗”两方面进行对比、评估、优化。 关于铃声下载门户的数据存储方案，张、王、李、赵4人分别提出了4种方案：分区、复制、子集、集中，他们各不相让，几乎要吵起来了...... 解决分歧、优化设计的方法是从“对吗”、“好吗”两方面进行对比评估。思维过程如下： 分区。在功能支持方面，没有任何问题。但是在非功能方面不好，例如没有解决性能问题。 复制。在功能支持方面依然没有任何问题，但是太贵，大量并不流行，甚至无人感兴趣的铃声被多次复制是无意义的。 子集。在非功能方面有着独有的优势，将部分流行的铃声在多点进行复制存储既促进了性能，又没有增加过多成本。但子集方式必然是一种辅助方式，因为它需要和另一种支持所有铃声保存的策略一起使用。 集中。用它和子集策略“搭配”，最为合适。 如此一来，总体的数据分布策略方案呈现出来：集中策略 + 子集策略。 "},"ch16/":{"url":"ch16/","title":"第16章 故事：困扰已久的非功能问题","keywords":"","body":"第16章 故事：困扰已久的非功能问题 非功能需求的满足程度对软件项目的成功非常关键......非功能需求分为质量属性和约束两大类。质量属性是软件系统的整体质量品质--所谓整体品质，就是往往和大多数功能都有关，而不是仅仅表现在某个功能“内部”。志宇约束性需求，它们是架构设计中必须遵循的限制，并有可能“衍生”出质量属性需求和功能需求。 -- 温昱，《软件架构设计》 那么非功能需求方面常见的问题是什么呢？......很多《需求规格说明书》中，会通过一个名为“设计原则”的小节来说明非功能需求，列出诸如高可靠性、高可用性、高扩展性等要求。但是很多开发人员根本不去看它，因为这样的定性描述是没有判断标准的，因此这种信息传递是无效的。 -- 徐峰， 《软件需求最佳实践》 软件架构设计为什么这么难？因为架构设计并不是简单的处理“纯粹的技术问题”，而是要面对“技术与业务的关系问题”。最终，要求架构师不仅懂业务，而且能理顺复杂的技术和业务之间的关系。 从面向业务的需求，到最终的面向技术的软件系统，要跨很大的鸿沟。软件架构设计就是要完成从面向业务到面向技术的转换，在鸿沟上架起一座桥梁。软件架构师根据各种需求进行架构设计，最终的软件架构包含了结构、协作、技术等方面的重要决策，为系统化的开发活动建立了基础。 接下来，请大家思考如下几个问题： 架构师是否应该懂需求？ 功能需求、非功能需求都要懂吗？ 生搬硬套需求标准是“懂需求”的应有表现吗？ 应对如何传达非功能目标的具体需求？ "},"ch16/16.1.html":{"url":"ch16/16.1.html","title":"16.1. “拜托，架构师不是需求分析师”","keywords":"","body":"16.1. “拜托，架构师不是需求分析师” 16.1.1. 故事：小魏请教老沈 为数不少架构师都认为自己是技术人员，职责是“知道需求之后设计出架构”。比如，老沈。 老沈是资深架构师，在某公司的设计部任职。一次，他首先的小魏充满虔诚的捧着几道题目来请教他。 答案分别为ABC、ABCD 老沈扫了一眼，皱起了眉头，语重心长的说：“小魏，你的理想不是要当首席架构师吗，怎么研究其需求来了？小伙子不要朝三暮四哟！” 小魏的表情充满了惊讶。稍过片刻，他鼓起了十二分勇气问道：“沈老师，你的意思是架构师不必深入研究需求？” 老沈道：“拜托，懂点儿软件工程好不好，现代软件工程讲究角色分工和团队合作，架构师不是需求分析师.....” 16.1.2. 探究：架构师必须懂需求 其实，除非特别简单的系统，否则架构师不能“吃透”需求，必然造成最终的系统无法很好的满足需求。但业界普遍存在的现实是：许多架构师的需求功底太差，输在架构设计的“起跑线”上。当然，架构师也是一大堆“苦衷”： 架构师不能“吃透”需求，的确出人意料。但是既然大部分企业为架构师安排了“技术晋升路线”，既然许多架构师也把自己当“纯粹的技术人员”，既然架构师必须研究“时髦技术”否则就被程序员看不起，既然设计模式和UML还在“排队”，需求吗就算了，那么架构师不能“吃透”需求，也就在情理之中了。 调侃归调侃（其实不无道理），但笔者一致认为：精通需求，是对架构师最基本的要求之一，不了解需求是现在许多架构师职业发展道路上的瓶颈。 值得强调的是，需求分析师和架构师这两个角色要掌握的需求知识并不完全一样。经典的观点是认为架构师应掌握的需求知识是需求分析师的一个子集，其实不然： 例如，之前所讲的“不同需求影响架构的不同原理”，需求分析师可以不去研究。 再例如，《软件工程的事实与缪误》中指出：“ 从需求转入设计时，因为制定方案过程的复杂性，会激增出大量的衍生需求（针对一种特定设计方案的需求）。设计需求是原始需求的50倍之多。” 总之，架构师必须懂需求。虽然无须研究诸如需求捕获等技术，但需求类型、需求影响架构的原理、质量属性间的互相影响关系都是必须精通的。 "},"ch16/16.2.html":{"url":"ch16/16.2.html","title":"16.2. “敢说ISO 9126不对，真牛”","keywords":"","body":"16.2. “敢说ISO 9126不对，真牛” 16.2.1. 故事：小冯与小汪的争论 小冯和小汪争得不可开交。 小冯是项目经理，他说：“不要随意扩大需求的Scope，更不要搞需求镀金，因为这些不仅意味着成本增加，还可能造成工期延误。” “是的。可是......”小汪是架构师，他的话说了半截就被打断了。 小冯抢着说：“所以，既然客户仅要求‘高可靠性’，我们就不能把它换成‘持续可用性’，更不应该随意扩大需求的范围，把安全性、可管理都加上。别忘了，成本超了、工期误了，可都是我这个项目经理扛着。” “像这种直接影响企业正常运营的系统，而不仅仅是‘可靠性’。”空气中已经有点火药味了，但小汪哪里肯退让，手指着培训教材上的一页继续坚持，“再请问，分布式的系统如果安全性差，可靠性怎么可能保证呢？！” 答案分别是：A、ABCD “《ISO 9216》的一级质量属性里就没有‘持续可用性’，而是‘可靠性’。” 小冯说。 “国际标准就不会错吗？”小汪豪气冲天。 “敢说ISO 9126不对，真牛......” 16.2.2. 探究：死抱需求标准，还是务实应变 科幻故事总是轻松的，现实中的故事却或多或少让人感到压力。 作为架构师，你是否认为：架构师重视需求 = 熟悉领域知识和业务？ 对，但不全面 -- 因为还要研究质量属性需求。那么，你是否又认为：懂质量需求 = 了解《ISO 9126》呢？ 我们的观点：重视标准，但在一定程度上必然要对之进行调整、扩充以适应实践要求。例如《ISO 9126》将质量属性描述成“树”，但实际上应该是“网”，安全性影响可靠性就是一例。 "},"ch16/16.3.html":{"url":"ch16/16.3.html","title":"16.3. “我说的很清楚，架构要灵活”","keywords":"","body":"16.3. “我说的很清楚，架构要灵活” 16.3.1. 故事：狮子说清了，绵羊没搞定 拿破仑说，“一只狮子率领一群绵羊的队伍，可以打败一只绵羊带领一群狮子的部队”。听到这话，许多软件企业可能觉得很高兴--因为不少公司都大量存在“一只狮子领导一群绵羊”这样的团队。 但是有这样的一个故事，就发生在“狮子带领一群绵羊”这样的团队。 卢总资历深厚，水平挺高。此时公司立项研发一款新产品，卢总亲自担纲。架构设计前期，他对几个年轻的架构师一再强调，架构一定要设计的灵活。......产品很快进入开发阶段，但是几次需求变更的来临，卢总发现架构的灵活性较差。 最后，卢总说“我的团队水平不高啊，我说的很清楚，架构要灵活，但最终还是过于僵硬。” 但真的只是团队的水平不高吗？ 16.3.2. 探究：交流质量要求，如何做到“说的明白、听得清楚” 为什么说，卢总的分析只对了一半呢？因为卢总要求的“灵活性”这个目标过于笼统，既然年轻的架构师水平偏弱，不能讲架构灵活的要求“落地”也就不奇怪了。 那么交流质量要求，如何做到“说的清楚、听得明白”呢？使用 “场景化”描述。 例如，通过分析将“灵活性”更明确的诠释为“客户端既可以采用.NET实现 又可以用Java实现”等一系列具体场景，对“狮子领导的绵羊团队”有效开展架构设计工作是大有裨益的。 "},"ch16/16.4.html":{"url":"ch16/16.4.html","title":"16.4. 展望本部分的后续内容","keywords":"","body":"16.4. 展望本部分的后续内容 3个故事讲完了，呈现在我们面前的是层层递进的3个要求： 架构师必须懂需求 需求 = 功能需求 + 非功能需求，架构师应同时关注两方面的需求，而且对质量的理解不应仅限于《ISO 9126》等标准 业界的同行们在交流非功能需求的时候，普遍存在“说不透”的现象，架构师应有意识的克服 接下来，我们将着重介绍“场景”技术，以及“目标-场景-决策”表这种务实有效的、以满足非功能需求为目标的设计思维方法。 "},"ch17/":{"url":"ch17/","title":"第17章 总论：非功能目标的设计环节","keywords":"","body":"第17章 总论：非功能目标的设计环节 为了提高综合客户满意度及不同质量属性的满意度，必须考虑计划和设计产品时的不同质量属性。 -- Stephen H.Kan，《软件质量工程》 质量属性很难定义，但它们经常可以区分产品是只完成了其应该完成的任务呢，还是使客户感到满意。 ......优秀的软件产品反映了这些竞争性质量属性的优化平衡。 -- Karl E.Wiegers, 《软件需求(第二版)》 作为决策者，架构师的工作影响着项目的成败，乃至公司的发展。我们须谨记：千万不要做“四拍”型的决策者。 决策时拍脑袋--就这么定了 指挥时拍胸脯--保证没问题 失误时拍大腿--我怎么没想到 追查时拍屁股--老子不干了 架构设计实践中，面对非功能需求目标时是最容易犯“拍脑袋”这个经典错误的。接下来介绍非功能目标的设计思维及其实践要领。 "},"ch17/17.1.html":{"url":"ch17/17.1.html","title":"17.1. 非功能目标的设计环节简介","keywords":"","body":"17.1. 非功能目标的设计环节简介 在我们当中，有不少人一厢情愿的任务：只要所开发的系统完成了用户期待的功能，项目就算成功了，但这不并不符合实际，忽视包括质量属性需求在内的非功能需求是很要命的。 为什么不少软件产品推出不久就要重新设计（美其名曰“架构重构”）？往往不是因为系统“不能用”，而是由于系统架构“太拙劣”--从难以维护、运行速度太慢 、稳定性差，甚至宕机频繁，到无法进行功能扩展、易遭受安全攻击等，不一而足。由此看来，软件的质量属性需求是不容忽视的，否则在大量的成本投入之后，很可能落得“失败”或“赔钱”的结果。 然而，软件的质量属性需求很“飘”，常常令架构师难以把握。如果缺乏足够的方法指导，即使勉强制定了设计决策也会觉得缺乏信心。 所以，解决问题的要害在于：如何使很“飘”的非功能目标“明确定义下来”。分析如下： 需求决定架构，架构设计的成果已属于解决方案的范畴 架构设计的过程是从“需求域”向“设计域”过度的过程 目标很飘，就意味着根据诸如“高性能”等非功能需求直接作出“设计决策”跨度过大了 需要一种“过度技术”来承上启下，它能笼统的非功能目标明确化，它能帮助架构师做出更有针对性的设计决策 它就是场景技术。 一句话，非功能目标的设计是以场景技术为核心手段、以目标-场景-决策表为思维工具，致力于支撑非功能目标的理性设计过程。 "},"ch17/17.2.html":{"url":"ch17/17.2.html","title":"17.2. 实际意义","keywords":"","body":"17.2. 实际意义 作为架构师，有了非功能目标设计环节相关方法的指导，将获得如下几点优势： 设计更有针对性 设计贵在务实，贵在有针对性。试想，如果世界上没有“高性能”这个高度简练、高度抽象的词，用户会怎么描述描述他的非功能要求？他一定会说一大堆“如果......则需要......”式的场景出来！ 所以，将一个目标明确为N个场景，是一种回归本源的做法，可以使架构师的设计更加有针对性、更加有效。 可操作性强 懂得了以场景为核心的非功能目标设计思维，架构师就知道“力往哪儿使”了。他们通过研究开发、维护、使用、变更等环境可能遇到的具体情况，不断发现场景，评估场景，做出决策......这是一个可操作性很强的思维实践过程。 其实所谓方法，就是帮着你将经验更系统的、更充分的使用起来的思维框架。所以，对有经验的架构师而言，他们的思维更有序、经验的应用更有理有据、面对更大的系统时信息更足。 当前，很大程度上，确定支持非功能目标的设计决策的过程是“只可意会”的。例如阅读《架构设计文档》时很难搞清楚“为什么”，这给架构新手的成长造成了莫大的障碍。而现在，非功能目标的设计思维明确化了、可视化了、可操作化了，有利于架构新手学习、理解和掌握。 避免过度设计 单凭经验为高质量属性而设计很容易造成过度设计，即引入的很多抽象和机制是不必要的，平白增加了设计复杂性。以“目标-场景-决策”表为工作的非功能目标设计方法将场景视为“一等公民”，使架构师很容易对非功能场景进行评估，通过权衡场景发生的几率、支持场景带来的价值、遗漏场景的代价等因素，来理性决定是否应支持该场景。 便于系统升级时参考 当系统架构不能适应新要求时，往往要对架构进行重构，此时软件架构师常犯的毛病是过于强调系统架构的缺点，而将过去的架构设计全盘否定，这样可能造成设计出的新架构的解决了新问题的同时也失去了已有的优点。而如果将“目标-场景-决策”表文档化，则有利于避免上述问题。 "},"ch17/17.3.html":{"url":"ch17/17.3.html","title":"17.3. 业界现状","keywords":"","body":"17.3. 业界现状 软件行业发展到今天，依然比较年轻。一个有趣的印证就是我们经常拿自己的行业和其他行业类比 -- 今天类比建筑行业，明天类比汽车行业，后台类比拍电影。 我并不能确定把架构师和哪个职业相类比最适合，但或许，架构师最嫉妒的职业是拳击。人家的目标永远正确：打到对方。而架构师，却要面对纠结在一起的“需求”--需求不是一个攻击目标，而是一堆攻击目标，而是一堆可能不够明确、相互矛盾的目标。昨天、今天、甚至明天，都会有相同的故事在上演：笼统界定的“非功能目标”让软件工程师深感困惑...... 这就是现状。 在这种状态之下，架构师不应“坐等”明确的需求，而是应该运用目标-场景-决策表等方法主动出击，设计成更有针对性的架构。 "},"ch17/17.4.html":{"url":"ch17/17.4.html","title":"17.4. 实践要领","keywords":"","body":"17.4. 实践要领 17.4.1. 场景思维 非功能需求支持是否到位，关键是靠场景思维的应用。归纳了场景思维在非功能目标设计中的重要性。 17.4.2. 纵穿环节 有著名厂商任务，架构设计的“第几步”应该是非功能考虑，这种观点是危险的。 非功能需求不可能是“速决战”，它必然是“持久战”，连编码都会影响到性能动能非功能属性，更何况概念架构设计和细化架构设计呢？所以架构师必须注意，非功能目标的考虑是纵穿架构师设计始终的环节。 "},"ch18/":{"url":"ch18/","title":"第18章 方法：“目标-场景-决策”表","keywords":"","body":"第18章 方法：“目标-场景-决策”表 软件的质量是设计出来的，这是公认的基本观点。 -- 邓成飞， 《软件工程管理》 很少有需求文档能够以一种可测试的细节捕获系统所有的质量需求，现实情况是设计师通常不得不填补空白并协调冲突。 -- Len Bass, 《软件架构实践（第2版）》 核心竞争力是什么？答案是：能力的稀缺性。 接下来介绍的目标-场景-决策表方法，可以帮助架构师快速建立非功能目标的设计思维，更理性的应对架构师普遍感到棘手的非功能支持问题，提升自己的核心竞争力。 "},"ch18/18.1.html":{"url":"ch18/18.1.html","title":"18.1. 场景技术","keywords":"","body":"18.1. 场景技术 18.1.1. 场景技术的历史 我们来浓缩描述一下场景技术的历史。 诞生 二战后，美国空军场景技术想象对手会采取哪些措施，然后准备相应的战略。 转变 196x年，兰德公司和曾供职于美国空军的赫尔曼.卡恩，将这种军事规划方法提炼成一种商业预测工具。 成名 壳牌公司运用它成功预测了1973年的石油危机，而名声鹊起。（《福布斯》杂志1970年还称壳牌公司为“丑美”，但后来......）。 应用 据贝恩公司2004年对960家跨国公司经理的调查表明，场景技术应用超过50%。 于是，许多同行困惑的“场景技术书籍难找”的问题也有了答案--由于场景技术并不产生于计算机行业，而且如今商业领域对场景技术的重视大大超出了软件行业，所以商业书店里“场景规划”方面的数据是我们有益参考。 18.1.2. 软件行业汇总场景技术的应用现状与展望 在软件行业，场景技术有着广泛的应用，并且未来场景技术会更加重要。 先说用例。很多软件从业者知道场景，都是从用例开始的。值得说明的有几点： 有书上说，场景就是用例，此观点错误。 用例是能给外部角色带来可见价值的交互序列，1个用例 = N个场景。 用例是功能需求实际上的标准，它并不能全面涵盖系统的非功能需求。 场景既可以是功能场景，也可以是非功能场景。 再考虑基于场景的架构评估方法。例如ATAM方法，其主要流程的示意图如下。在此类方法中，场景技术作为一种质疑技术发挥作用--架构对目标的支持怎么样啊？ 场景的“应用案例还有很多”，比如： 测试用例 业务需求 ...... 至此，可以得到一个重要的总体结论： 场景是基础技术，用例是应用技术。 为了以结构化的方式描述“能给外部角色带来可见的交互序列”，将成功场景和各种意外场景“打包”形成了用例。 于是不难理解，用于测试设计的“测试用例”，用于评审的“基于场景的架构评估方法”、用于支持非功能目标设计方法论的“目标-场景-决策表”......都是场景技术的具体应用。 为此，软件行业未来在需求领域必然会不断发展： 通过场景化，增强非功能需求的可验证性（那时候，业界公认的软件过程中描述需求分析师的工作是，会出现类似“目标-场景-决策报表”的很多工作......） 场景技术和“定量的需求”日渐结合，发挥两个技术各种的优点--本质上，场景和定量是正交的、相互独立的两种技术，它们的“珠联璧合”是必然趋势。 18.1.3. 场景的5要素与场景卡 建议场景应该包含5要素： 影响来源：来自系统外部或系统内部的触发因素。 如何影响：影响来源施加了什么影响。 受影响对象：默认为“本系统”。 问题或价值：受影响对象因此出现什么问题，或者需要体现什么价值。 所处环境：此时，所处的环境或上下文为何（此要素为可选要素）。 了解了场景的5要素，场景卡就非常容易理解了；一张5要素为核心内容的需求采集卡。当需求分析师并未通过场景技术明确定义非功能需求，当架构师也深感难以到位的发现有价值的场景时，架构师可以借助场景卡来激活团队的力量--让大家提交场景卡。 "},"ch18/18.2.html":{"url":"ch18/18.2.html","title":"18.2. “目标-场景-决策”表","keywords":"","body":"18.2. “目标-场景-决策”表 软件界泰斗Edsger Dijkstra指出，“我们所使用的工具深刻的影响我们的思考习惯，从而也影响了我们的思考能力”。 目标-场景-决策表将思考过程形象化、可视化了，能够非常务实有效的处境架构设计思维。 实践中，架构师必须对场景进行评估，以决定是否支持这个场景。架构师经常要考虑的场景评估因素包括： 价值大小 代价大小 开发难度高低 技术趋势 出现几率 最后，必须提醒的是“不支持某场景”恰恰是架构师的一种重要决策--如果每个场景都给予支持，理性设计就无从谈起，多度设计都在所难免了。如下面的目标-场景-决策表中，就明确决定了：不支持PAD作为项目管理系统的客户端。 "},"appendix-a/":{"url":"appendix-a/","title":"附录A 架构设计原则","keywords":"","body":"附录A 架构设计原则 "},"appendix-a/base.html":{"url":"appendix-a/base.html","title":"基本原则","keywords":"","body":"基本原则 "},"appendix-a/features.html":{"url":"appendix-a/features.html","title":"功能选择","keywords":"","body":"功能选择 "},"appendix-a/server-design.html":{"url":"appendix-a/server-design.html","title":"服务端设计与并发","keywords":"","body":"服务端设计与并发 "},"appendix-a/distributed-systems.html":{"url":"appendix-a/distributed-systems.html","title":"分布式系统","keywords":"","body":"分布式系统 "},"appendix-a/ux.html":{"url":"appendix-a/ux.html","title":"用户体验","keywords":"","body":"用户体验 "},"appendix-a/hard-problems.html":{"url":"appendix-a/hard-problems.html","title":"艰难的问题","keywords":"","body":"艰难的问题 "},"appendix-a/Conclusion.html":{"url":"appendix-a/Conclusion.html","title":"总结","keywords":"","body":"总结 "}}